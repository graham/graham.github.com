{"version":3,"sources":["webpack:///simplesearch.bundle.js","webpack:///./app/simplesearch/src/main.tsx","webpack:///./src/lib.tsx?c6d6","webpack:///./src/dispatch.ts?2338","webpack:///./app/simplesearch/src/table.tsx","webpack:///./app/simplesearch/src/text_to_filter_fun.ts"],"names":["webpackJsonp","module","exports","__webpack_require__","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","React","ReactDOM","myproj_lib_1","table_1","HelloWorld","HWState","_super","props","call","render","docs","i","push","fuzzy","num","createElement","SearchableDataTable","initDocs","Component","document","getElementById","test_lib_working","debounce","func","wait","immediate","now","Date","getTime","later","last","timestamp","timeout","setTimeout","result","apply","context","args","arguments","callNow","ensureValidKeys","state","ensureKeys","LOADED_KEY","return_state","undefined","_i","ensureKeys_1","length","key","is_loaded","mapMerge","left","right","new_map","_a","source","_b","source_1","console","log","dispatch_1","global_dispatcher","dispatch_object_to_target","_dispatcher","event","routing_search","payload","target_fn","options","sp_event","split","sp_search","final_payload","routing_path","last_successful_search_part","index","event_part","search_part","new_routing_root","join","new_routing","notify","Dispatcher","listeners","event_queue","is_dispatching","is_capturing_local_storage_events","function_name","listen","routing_key","target","setState","listen_fn","event_routing_key","indexOf","flush_queue","broadcast","obj","fn","flush","substring","inner_queue","item","slice","dispatch_event","_this_1","remaining_listeners","row","object_routing","object_target_fn","object_options","e","capture_local_storage_changes","_this","originalSetItem_1","localStorage","setItem","text_to_filter_fun_1","TableState","TableProps","query_value","items","filterFn","handleChange","bind","handleSubmit","next_state","value","build_fn","preventDefault","getVisibleItems","filter","renderRow","visibleItems","map","onSubmit","type","onChange","SearchType","Cond","cond_lookup","=","Equal","!","NotEqual",">","GreaterThan","<","LessThan","~","Fuzzy","?","Exists","$","ArgValueInItemSeq","fn_lookup","arg","ItemValueInArgSeq","target_type","search","ComposeOR","arg_1","cond","narg","ComposeAND","arg_2","safe_split","s","split_char","block_chars","\"","'","(","[","`","partitions","current_word","in_block","block_start_char","chr","is_cond","token","cond_parse","str_starts_with","st","isNaN","build_filter_fn_from_tokens","conditions","s_1","outer_item","lambda","enclosed","addrem","fn_cond_enum","ret","key_parts","key_parts_1","part","Include","Exclude","_index","_accum","conditions_1","q","fuzzy_key","macro_map","final_tokens","basic_tokens","basic_tokens_1","str_token","first_char","_c","_d","componse_cond","sub_conds","_e","_f","arg_slice","_g"],"mappings":"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","file":"simplesearch.bundle.js","sourcesContent":["webpackJsonp([2],[\n/* 0 */\n/*!***************************************!*\\\n  !*** ./app/simplesearch/src/main.tsx ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar React = __webpack_require__(/*! react */ 1);\n\tvar ReactDOM = __webpack_require__(/*! react-dom */ 1);\n\tvar myproj_lib_1 = __webpack_require__(/*! myproj-lib */ 5);\n\tvar table_1 = __webpack_require__(/*! ./table */ 7);\n\tvar HWState = (function () {\n\t    function HWState() {\n\t    }\n\t    return HWState;\n\t}());\n\tvar HelloWorld = (function (_super) {\n\t    __extends(HelloWorld, _super);\n\t    function HelloWorld(props) {\n\t        _super.call(this, props);\n\t    }\n\t    HelloWorld.prototype.render = function () {\n\t        var docs = [];\n\t        for (var i = 0; i < 100000; i++) {\n\t            docs.push({ 'fuzzy': 'hello ' + i, num: i });\n\t        }\n\t        return React.createElement(table_1.SearchableDataTable, {initDocs: docs});\n\t    };\n\t    return HelloWorld;\n\t}(React.Component));\n\tReactDOM.render(React.createElement(HelloWorld, null), document.getElementById('content'));\n\tmyproj_lib_1.test_lib_working();\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/*!*********************!*\\\n  !*** ./src/lib.tsx ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar dispatch_1 = __webpack_require__(/*! ./dispatch */ 6);\n\texports.global_dispatcher = dispatch_1.global_dispatcher;\n\t// Taken directly from `npm install debounce` because it doesn't have clean types.\n\tfunction debounce(func, wait, immediate) {\n\t    function now() {\n\t        return (new Date()).getTime();\n\t    }\n\t    ;\n\t    var timeout, args, context, timestamp, result;\n\t    if (null == wait)\n\t        wait = 100;\n\t    function later() {\n\t        var last = now() - timestamp;\n\t        if (last < wait && last > 0) {\n\t            timeout = setTimeout(later, wait - last);\n\t        }\n\t        else {\n\t            timeout = null;\n\t            if (!immediate) {\n\t                result = func.apply(context, args);\n\t                if (!timeout)\n\t                    context = args = null;\n\t            }\n\t        }\n\t    }\n\t    ;\n\t    return function debounced() {\n\t        context = this;\n\t        args = arguments;\n\t        timestamp = now();\n\t        var callNow = immediate && !timeout;\n\t        if (!timeout)\n\t            timeout = setTimeout(later, wait);\n\t        if (callNow) {\n\t            result = func.apply(context, args);\n\t            context = args = null;\n\t        }\n\t        return result;\n\t    };\n\t}\n\texports.debounce = debounce;\n\t;\n\tfunction ensureValidKeys(state, ensureKeys) {\n\t    var LOADED_KEY = \"is_loaded\";\n\t    var return_state = {};\n\t    if (state[LOADED_KEY] !== undefined) {\n\t        throw (\"Cant use `is_loaded` as key in state for ensureValidKeys\");\n\t    }\n\t    for (var _i = 0, ensureKeys_1 = ensureKeys; _i < ensureKeys_1.length; _i++) {\n\t        var key = ensureKeys_1[_i];\n\t        if (!state[key]) {\n\t            return { \"is_loaded\": false };\n\t        }\n\t        return_state[key] = state[key];\n\t    }\n\t    return_state[\"is_loaded\"] = true;\n\t    return return_state;\n\t}\n\texports.ensureValidKeys = ensureValidKeys;\n\t;\n\tfunction mapMerge(left, right) {\n\t    var new_map = {};\n\t    for (var _i = 0, _a = [left, right]; _i < _a.length; _i++) {\n\t        var source = _a[_i];\n\t        for (var _b = 0, source_1 = source; _b < source_1.length; _b++) {\n\t            var key = source_1[_b];\n\t            new_map[key] = source[key];\n\t        }\n\t    }\n\t    return new_map;\n\t}\n\texports.mapMerge = mapMerge;\n\t;\n\tfunction test_lib_working() {\n\t    console.log(\"Lib is working!\");\n\t}\n\texports.test_lib_working = test_lib_working;\n\n\n/***/ },\n/* 6 */\n/*!*************************!*\\\n  !*** ./src/dispatch.ts ***!\n  \\*************************/\n/***/ function(module, exports) {\n\n\t/*\n\t   Dispatching events isn't as easy as you want it to be.\n\t\n\t   While the Dispatcher object (below) is relatively simple, the ruleset\n\t   that determines what to dispatch is a little more complex.\n\t\n\t   In a simple case, a object registers for a simple event:\n\t\n\t     global_dispatch.listen('page.tick', mytarget);\n\t\n\t   When notify() is called with 'page.tick', the `mytarget` object has its\n\t   `setState` method called with whatever arg is passed to the notify()\n\t   method. When the number of 'parts' is equal, this comparison is simple\n\t   the parts must match (or the search must be a '*').\n\t\n\t   Thus, 'page.*' would match 'page.tick', but not 'otherthing.tick'.\n\t\n\t   While this would be good enough for most cases, we want to avoid\n\t   the following.\n\t\n\t     // This is what we want to avoid.\n\t     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n\t        console.log(\"The ID is: \" + payload.info.id);\n\t     });\n\t\n\t     // dispatch our complex user object.\n\t     global_dispatch.notify('user.123', {'info':{'id':1}});\n\t\n\t     // dispatch a different piece of user data.\n\t     // This would result in an error.\n\t     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\t\n\t   Instead, since we know the search path, we can dig into the payload\n\t   object, and return only what the listener asked for.\n\t\n\t   Thus,\n\t\n\t     // This is what we actually do.\n\t     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n\t        console.log(\"The ID is \" + payload.id);\n\t     });\n\t\n\t     // dispatch our complex user object, the above will be called.\n\t     global_dispatch.notify('user.123', {'info':{'id':1}});\n\t\n\t     // dispatch a different piece of user data.\n\t     // This will not invoke the handler above, because the\n\t     // route did not match. See `dispatch_object_to_target`\n\t     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\t\n\t   This avoids nasty bugs, and makes sure that your handlers\n\t   only ever get the data they requested. Handlers can use * at the\n\t   end of their match in order to get all the keys.\n\t\n\t   Keep in mind this only works for events that are dictionaries\n\t   or objects.\n\t*/\n\t\"use strict\";\n\tfunction dispatch_object_to_target(_dispatcher, event, routing_search, payload, target_fn, options) {\n\t    var sp_event = event.split('.');\n\t    var sp_search = routing_search.split('.');\n\t    var final_payload = payload;\n\t    var routing_path = [];\n\t    var last_successful_search_part = null;\n\t    for (var index = 0; index < sp_search.length; index++) {\n\t        var event_part = sp_event[index];\n\t        var search_part = sp_search[index];\n\t        if (event_part == undefined) {\n\t            if (search_part == '*') {\n\t                var new_routing_root = routing_path.join('.');\n\t                for (var i in final_payload) {\n\t                    var new_routing = new_routing_root + '.' + i;\n\t                    console.log(\"new event: \" + new_routing);\n\t                    _dispatcher.notify(new_routing, final_payload[i]);\n\t                }\n\t            }\n\t            else if (final_payload[search_part] != undefined) {\n\t                final_payload = final_payload[search_part];\n\t                last_successful_search_part = search_part;\n\t                routing_path.push(search_part);\n\t            }\n\t            else {\n\t                return false;\n\t            }\n\t        }\n\t        else if (search_part != '*' && search_part != event_part) {\n\t            return false;\n\t        }\n\t        else {\n\t            last_successful_search_part = event_part;\n\t            routing_path.push(event_part);\n\t        }\n\t    }\n\t    if (last_successful_search_part != null) {\n\t        var d = {};\n\t        d[last_successful_search_part] = final_payload;\n\t        final_payload = d;\n\t    }\n\t    return target_fn(final_payload, routing_path.join('.'));\n\t}\n\t;\n\t// The dispatcher is very similar to the one described in the flux\n\t// documentation: https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html\n\t// This dispatcher is intended to be a singleton (but we don't enforce that)\n\tvar Dispatcher = (function () {\n\t    function Dispatcher() {\n\t        this.listeners = [];\n\t        this.event_queue = [];\n\t        this.is_dispatching = false;\n\t        this.is_capturing_local_storage_events = false;\n\t        this.function_name = 'setState';\n\t        this.is_dispatching = false;\n\t    }\n\t    // Call the `function_name` on the target object. By default\n\t    // this calls setState (which is the norm for React).\n\t    Dispatcher.prototype.listen = function (routing_key, target, options) {\n\t        this.listeners.push([routing_key,\n\t            function () {\n\t                target.setState(arguments[0]);\n\t            },\n\t            options\n\t        ]);\n\t    };\n\t    // Listen with a custom function callback.\n\t    Dispatcher.prototype.listen_fn = function (routing_key, target, options) {\n\t        this.listeners.push([routing_key, target, options]);\n\t    };\n\t    // Notify listeners that you have data for a key.\n\t    Dispatcher.prototype.notify = function (event_routing_key, args) {\n\t        if (event_routing_key.indexOf('*') > -1) {\n\t            throw \"You can't notify with a *; use flush or broadcast.\";\n\t        }\n\t        this.event_queue.push([event_routing_key, args]);\n\t        if (!this.is_dispatching) {\n\t            this.flush_queue();\n\t        }\n\t    };\n\t    // Broadcast an event to all handlers, regardless of their listening key.\n\t    // This can be used to reset all of your handlers, or to notify them of some\n\t    // other global change.\n\t    Dispatcher.prototype.broadcast = function (event) {\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var obj = _a[_i];\n\t            var fn = obj[1];\n\t            fn(event, '_');\n\t        }\n\t    };\n\t    // Flush will notify any listener that matches a \"startswith\" comparison\n\t    // Usage in documentation will give more insight into why you might need this.\n\t    Dispatcher.prototype.flush = function (event_routing_key, args) {\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var obj = _a[_i];\n\t            var fn = obj[1];\n\t            var key = obj[0];\n\t            if (key.substring(0, event_routing_key.length) == event_routing_key) {\n\t                fn(args, '-');\n\t            }\n\t        }\n\t    };\n\t    Dispatcher.prototype.flush_queue = function () {\n\t        this.is_dispatching = true;\n\t        // lets preserve the current_event queue.\n\t        var inner_queue = this.event_queue;\n\t        // and replace it with an empty queue, that way\n\t        // if events are created during the broadcast of\n\t        // the following events, we cant get into a\n\t        // infinite loop.\n\t        this.event_queue = [];\n\t        while (inner_queue.length) {\n\t            var item = inner_queue.slice(0, 1)[0];\n\t            inner_queue = inner_queue.slice(1);\n\t            this.dispatch_event(item[0], item[1]);\n\t        }\n\t        if (this.event_queue.length > 0) {\n\t            // somewhere in the process of dispatching\n\t            // these events more events came in.\n\t            // lets give the UI thread a chance to render\n\t            // and we'll start dispatching again.\n\t            var _this_1 = this;\n\t            setTimeout(function () {\n\t                _this_1.flush_queue();\n\t            }, 5);\n\t        }\n\t        else {\n\t            // No other events were created, so we can\n\t            // gracefully stop. Future calls to notify\n\t            // will call flush_queue().\n\t            this.is_dispatching = false;\n\t        }\n\t    };\n\t    // The actual work of dispatching a single event.\n\t    Dispatcher.prototype.dispatch_event = function (event_routing_key, args) {\n\t        var remaining_listeners = [];\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var row = _a[_i];\n\t            var object_routing = row[0];\n\t            var object_target_fn = row[1];\n\t            var object_options = row[2];\n\t            try {\n\t                // Attempt to dispatch, with some extra rules to dig into objects.\n\t                dispatch_object_to_target(this, event_routing_key, object_routing, args, object_target_fn, object_options);\n\t                // If we make it here, we didn't throw an exception (or we didn't call fn)\n\t                remaining_listeners.push(row);\n\t            }\n\t            catch (e) {\n\t                console.log('Dropping handler for `' + row[0] + '` on `' +\n\t                    typeof row[1].constructor + '` because of exception: ' + e);\n\t            }\n\t        }\n\t        this.listeners = remaining_listeners;\n\t    };\n\t    // Warning, this is here to show you how this might work, but it hides\n\t    // the fact that setItem will clobber complex objects ([], {}) into a\n\t    // string while adding them to the database.\n\t    Dispatcher.prototype.capture_local_storage_changes = function () {\n\t        var _this = this;\n\t        if (this.is_capturing_local_storage_events) {\n\t            var originalSetItem_1 = localStorage.setItem;\n\t            localStorage.setItem = function () {\n\t                originalSetItem_1.apply(this, arguments);\n\t                _this.notify(arguments[0], arguments[1]);\n\t            };\n\t            this.is_capturing_local_storage_events = true;\n\t        }\n\t        else {\n\t            console.log(\"successive calls to capture_local_storage_changes are ignored.\");\n\t        }\n\t    };\n\t    return Dispatcher;\n\t}());\n\texports.Dispatcher = Dispatcher;\n\tvar global_dispatcher = new Dispatcher();\n\texports.global_dispatcher = global_dispatcher;\n\n\n/***/ },\n/* 7 */\n/*!****************************************!*\\\n  !*** ./app/simplesearch/src/table.tsx ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar React = __webpack_require__(/*! react */ 1);\n\tvar text_to_filter_fun_1 = __webpack_require__(/*! ./text_to_filter_fun */ 8);\n\tvar myproj_lib_1 = __webpack_require__(/*! myproj-lib */ 5);\n\tvar TableState = (function () {\n\t    function TableState() {\n\t    }\n\t    return TableState;\n\t}());\n\tvar TableProps = (function () {\n\t    function TableProps() {\n\t    }\n\t    return TableProps;\n\t}());\n\tvar SearchableDataTable = (function (_super) {\n\t    __extends(SearchableDataTable, _super);\n\t    function SearchableDataTable(props) {\n\t        _super.call(this, props);\n\t        this.state = {\n\t            query_value: '',\n\t            items: this.props.initDocs,\n\t            filterFn: function () { return true; }\n\t        };\n\t        this.handleChange = this.handleChange.bind(this);\n\t        this.handleSubmit = this.handleSubmit.bind(this);\n\t        this.handleChange = myproj_lib_1.debounce(this.handleChange, 100);\n\t    }\n\t    SearchableDataTable.prototype.handleChange = function (event) {\n\t        var next_state = {\n\t            query_value: event.target.value,\n\t            filterFn: text_to_filter_fun_1.build_fn(event.target.value)\n\t        };\n\t        this.setState(myproj_lib_1.mapMerge(this.state, next_state));\n\t    };\n\t    SearchableDataTable.prototype.handleSubmit = function (event) {\n\t        event.preventDefault();\n\t    };\n\t    SearchableDataTable.prototype.getVisibleItems = function () {\n\t        return this.state.items.filter(this.state.filterFn).slice(0, 100);\n\t    };\n\t    SearchableDataTable.prototype.renderRow = function (item) {\n\t        return React.createElement(\"tr\", null, \n\t            React.createElement(\"td\", null, \n\t                \"Hello \", \n\t                item.num)\n\t        );\n\t    };\n\t    SearchableDataTable.prototype.render = function () {\n\t        var visibleItems = this.getVisibleItems().map(this.renderRow);\n\t        return (React.createElement(\"div\", null, \n\t            React.createElement(\"form\", {onSubmit: this.handleSubmit}, \n\t                React.createElement(\"label\", null, \"Search\"), \n\t                React.createElement(\"input\", {type: \"text\", value: this.state.query_value, onChange: this.handleChange}), \n\t                React.createElement(\"input\", {type: \"submit\", value: \"Submit\"}), \n\t                React.createElement(\"div\", null, \n\t                    visibleItems.length, \n\t                    \" of \", \n\t                    this.state.items.length, \n\t                    \" items.\")), \n\t            React.createElement(\"table\", null, visibleItems)));\n\t    };\n\t    return SearchableDataTable;\n\t}(React.Component));\n\texports.SearchableDataTable = SearchableDataTable;\n\n\n/***/ },\n/* 8 */\n/*!****************************************************!*\\\n  !*** ./app/simplesearch/src/text_to_filter_fun.ts ***!\n  \\****************************************************/\n/***/ function(module, exports) {\n\n\t/* Todo\n\t\n\t   - text to conditions.\n\t   - conditions to text.\n\t   - better tokens.\n\t\n\t*/\n\t\"use strict\";\n\t/*\n\t   text_to_filter takes a simple (gmail like) search string and returns\n\t   a javascript function that accepts one argument, a javascript object,\n\t   and returns a true or false depending on if that object matches the\n\t   search string.\n\t\n\t   The primary goals are expressiveness and speed, with a secondary goals\n\t   on readability. This second goal is easy to overcome with macros which\n\t   allow search criteria rewriting per use (examples below).\n\t\n\t   Generated Function -> The function returned by calling build_fn with\n\t                         some search criteria.\n\t\n\t   Item -> Generally refers to the javascript object passed to the\n\t           generated function.\n\t\n\t   Search Type determines if a positive match will include or exclude the\n\t   item in the search result. Prepending a '\\' or '-' before a condition\n\t   sets that criteria to exclude, '+' or '/' for include (if neither are\n\t   present include is assumed).\n\t */\n\tvar SearchType;\n\t(function (SearchType) {\n\t    SearchType[SearchType[\"Include\"] = 0] = \"Include\";\n\t    SearchType[SearchType[\"Exclude\"] = 1] = \"Exclude\";\n\t})(SearchType || (SearchType = {}));\n\t;\n\t/*\n\t   Cond is the basic building block of all our comparisons, more detail\n\t   inline.\n\t\n\t   Where:\n\t     item  => passed in item.\n\t     key   => queried key.\n\t     value => value of argument\n\t*/\n\tvar Cond;\n\t(function (Cond) {\n\t    Cond[Cond[\"Exists\"] = 0] = \"Exists\";\n\t    Cond[Cond[\"Equal\"] = 1] = \"Equal\";\n\t    Cond[Cond[\"NotEqual\"] = 2] = \"NotEqual\";\n\t    Cond[Cond[\"LessThan\"] = 3] = \"LessThan\";\n\t    Cond[Cond[\"GreaterThan\"] = 4] = \"GreaterThan\";\n\t    Cond[Cond[\"ArgValueInItemSeq\"] = 5] = \"ArgValueInItemSeq\";\n\t    Cond[Cond[\"ItemValueInArgSeq\"] = 6] = \"ItemValueInArgSeq\";\n\t    Cond[Cond[\"Fuzzy\"] = 7] = \"Fuzzy\";\n\t    Cond[Cond[\"ComposeOR\"] = 8] = \"ComposeOR\";\n\t    Cond[Cond[\"ComposeAND\"] = 9] = \"ComposeAND\";\n\t    Cond[Cond[\"ComposeNOT\"] = 10] = \"ComposeNOT\"; // Composeable NOT (not yet implemented)\n\t})(Cond || (Cond = {}));\n\t;\n\t// Start characters can only be one charater long, may add more here in\n\t// the future if needed.\n\tvar cond_lookup = {\n\t    '=': Cond.Equal,\n\t    '!': Cond.NotEqual,\n\t    '>': Cond.GreaterThan,\n\t    '<': Cond.LessThan,\n\t    '~': Cond.Fuzzy,\n\t    '?': Cond.Exists,\n\t    '$': Cond.ArgValueInItemSeq,\n\t};\n\t// Our cond function lookup.\n\tvar fn_lookup = {};\n\tfn_lookup[Cond.Equal] = function (value, arg) {\n\t    return value == arg;\n\t};\n\tfn_lookup[Cond.NotEqual] = function (value, arg) {\n\t    return value != arg;\n\t};\n\tfn_lookup[Cond.LessThan] = function (value, arg) {\n\t    return value < arg;\n\t};\n\tfn_lookup[Cond.GreaterThan] = function (value, arg) {\n\t    return value > arg;\n\t};\n\tfn_lookup[Cond.Exists] = function (value, arg) {\n\t    return value !== undefined;\n\t};\n\tfn_lookup[Cond.ArgValueInItemSeq] = function (value, arg) {\n\t    return value.indexOf(arg) != -1;\n\t};\n\tfn_lookup[Cond.ItemValueInArgSeq] = function (value, arg) {\n\t    return arg.indexOf(value) == -1;\n\t};\n\tfn_lookup[Cond.Fuzzy] = function (value, arg) {\n\t    var target_type = typeof (value);\n\t    if (arg.length == 0) {\n\t        return false;\n\t    }\n\t    // Coerce the type if both sides don't match.\n\t    if (target_type == undefined) {\n\t        return false;\n\t    }\n\t    else if (target_type == \"string\") {\n\t        return value.search(arg) != -1;\n\t    }\n\t    else if (target_type == \"number\") {\n\t        return (\"\" + value).search(arg) != -1;\n\t    }\n\t    return false;\n\t};\n\t// Evaluate the sub parts.\n\tfn_lookup[Cond.ComposeOR] = function (value, arg) {\n\t    for (var _i = 0, arg_1 = arg; _i < arg_1.length; _i++) {\n\t        var _a = arg_1[_i], cond = _a[0], narg = _a[1];\n\t        if (fn_lookup[cond].apply(this, [value, narg])) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t};\n\t// Evaluate the sub parts.\n\tfn_lookup[Cond.ComposeAND] = function (value, arg) {\n\t    for (var _i = 0, arg_2 = arg; _i < arg_2.length; _i++) {\n\t        var _a = arg_2[_i], cond = _a[0], narg = _a[1];\n\t        if (fn_lookup[cond].apply(this, [value, narg]) == false) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t};\n\t// Tokenize a search in a way that we feel good about.\n\tvar safe_split = function safe_split(s) {\n\t    var split_char = ' ';\n\t    var block_chars = {\n\t        '\"': '\"',\n\t        \"'\": \"'\",\n\t        '(': ')',\n\t        '[': ']',\n\t        '`': '`'\n\t    };\n\t    var partitions = [];\n\t    var current_word = [];\n\t    var in_block = false;\n\t    var block_start_char = null;\n\t    for (var i = 0; i < s.length; i++) {\n\t        var chr = s[i];\n\t        if (in_block) {\n\t            if (chr == block_chars[block_start_char]) {\n\t                current_word.push(chr);\n\t                in_block = false;\n\t                block_start_char = null;\n\t            }\n\t            else {\n\t                current_word.push(chr);\n\t            }\n\t        }\n\t        else {\n\t            if (split_char.indexOf(chr) != -1) {\n\t                partitions.push(current_word.join(''));\n\t                current_word = [];\n\t            }\n\t            else {\n\t                if (block_chars[chr] != undefined) {\n\t                    // we should start a block\n\t                    in_block = true;\n\t                    block_start_char = chr;\n\t                    current_word.push(chr);\n\t                }\n\t                else {\n\t                    current_word.push(chr);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if (current_word.length) {\n\t        partitions.push(current_word.join(''));\n\t    }\n\t    return partitions;\n\t};\n\t// Test to see if our token is a condition or just\n\t// normal text input. `` grave to escape.\n\tvar is_cond = function (token) {\n\t    if (token.search(':') != -1 && token[0] != '\\`') {\n\t        return true;\n\t    }\n\t    return false;\n\t};\n\t// Parse a cond into it's parts, coerce the value if it\n\t// makes sense.\n\tvar cond_parse = function (arg) {\n\t    var cond = Cond.Equal;\n\t    var str_starts_with = function (key, st) {\n\t        if (key.slice(0, st.length) == st) {\n\t            return true;\n\t        }\n\t        else {\n\t            return false;\n\t        }\n\t    };\n\t    for (var key in cond_lookup) {\n\t        if (str_starts_with(arg, key)) {\n\t            cond = cond_lookup[key];\n\t            arg = arg.slice(key.length);\n\t        }\n\t    }\n\t    if (!isNaN(+arg)) {\n\t        arg = +arg;\n\t    }\n\t    if (arg == 't' || arg == 'true') {\n\t        arg = true;\n\t    }\n\t    else if (arg == 'f' || arg == 'false') {\n\t        arg = false;\n\t    }\n\t    return [cond, arg];\n\t};\n\t// Given a set of parsed tokens, build a filter function.\n\tvar build_filter_fn_from_tokens = function (s) {\n\t    var conditions = [];\n\t    for (var _i = 0, s_1 = s; _i < s_1.length; _i++) {\n\t        var outer_item = s_1[_i];\n\t        var lambda = (function (enclosed) {\n\t            return function (item) {\n\t                var addrem = enclosed[0];\n\t                var fn_cond_enum = enclosed[1];\n\t                var key = enclosed[2];\n\t                var arg = enclosed[3];\n\t                var ret = false;\n\t                try {\n\t                    var key_parts = key.split('.');\n\t                    var value = item;\n\t                    if (key_parts.length == 1) {\n\t                        value = value[key];\n\t                    }\n\t                    else {\n\t                        for (var _i = 0, key_parts_1 = key_parts; _i < key_parts_1.length; _i++) {\n\t                            var part = key_parts_1[_i];\n\t                            if (value[part] == undefined) {\n\t                                return false;\n\t                            }\n\t                            value = value[part];\n\t                        }\n\t                    }\n\t                    if (typeof value == \"function\") {\n\t                        if (fn_cond_enum == Cond.Exists) {\n\t                            ret = true;\n\t                        }\n\t                        else {\n\t                            ret = value.apply(item, [arg]);\n\t                        }\n\t                    }\n\t                    else if (typeof value == \"undefined\") {\n\t                        ret = false;\n\t                    }\n\t                    else {\n\t                        ret = fn_lookup[fn_cond_enum](value, arg);\n\t                    }\n\t                }\n\t                catch (e) {\n\t                    console.log(\"Exception in cond: \", fn_lookup[fn_cond_enum]);\n\t                    ;\n\t                }\n\t                if (addrem == SearchType.Include) {\n\t                    return ret;\n\t                }\n\t                else if (addrem == SearchType.Exclude) {\n\t                    return !ret;\n\t                }\n\t                else {\n\t                    console.log(\"UNKNOWN SEARCH TYPE:\", addrem);\n\t                    return ret;\n\t                }\n\t            };\n\t        })(outer_item);\n\t        conditions.push(lambda);\n\t    }\n\t    return function (item, _index, _accum) {\n\t        for (var _i = 0, conditions_1 = conditions; _i < conditions_1.length; _i++) {\n\t            var fn = conditions_1[_i];\n\t            if (fn(item) == false) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t};\n\t// Compose a list of tokens and then use the build_filter_fn_from_tokens\n\t// to create a function for the user to filter with.\n\tvar build_fn = function (q, options) {\n\t    if (options == undefined) {\n\t        options = {};\n\t    }\n\t    var fuzzy_key = options['fuzzy_key'] || 'fuzzy';\n\t    var macro_map = options['macros'] || {};\n\t    var final_tokens = [];\n\t    var basic_tokens = safe_split(q);\n\t    for (var _i = 0, basic_tokens_1 = basic_tokens; _i < basic_tokens_1.length; _i++) {\n\t        var str_token = basic_tokens_1[_i];\n\t        if (is_cond(str_token)) {\n\t            var addrem = SearchType.Include;\n\t            var first_char = str_token[0];\n\t            if (first_char == '-' || first_char == '\\\\') {\n\t                addrem = SearchType.Exclude;\n\t                str_token = str_token.slice(1);\n\t            }\n\t            else if (first_char == '/' || first_char == '+') {\n\t                addrem = SearchType.Include;\n\t                str_token = str_token.slice(1);\n\t            }\n\t            var split = str_token.split(':');\n\t            var key = split[0];\n\t            for (var _a = 0, _b = split.slice(1); _a < _b.length; _a++) {\n\t                var arg = _b[_a];\n\t                if (arg.length > 0) {\n\t                    if (macro_map[key] != undefined) {\n\t                        _c = macro_map[key](key, arg), key = _c[0], arg = _c[1];\n\t                    }\n\t                    if (arg.search(',') == -1) {\n\t                        var _d = cond_parse(arg), cond = _d[0], narg = _d[1];\n\t                        final_tokens.push([addrem, cond, key, narg]);\n\t                    }\n\t                    else {\n\t                        var componse_cond = Cond.ComposeOR;\n\t                        if (arg[0] == '&') {\n\t                            componse_cond = Cond.ComposeAND;\n\t                            arg = arg.slice(1);\n\t                        }\n\t                        else if (arg[0] == '|') {\n\t                            componse_cond = Cond.ComposeOR;\n\t                            arg = arg.slice(1);\n\t                        }\n\t                        var sub_conds = [];\n\t                        for (var _e = 0, _f = arg.split(','); _e < _f.length; _e++) {\n\t                            var arg_slice = _f[_e];\n\t                            var _g = cond_parse(arg_slice), cond = _g[0], narg = _g[1];\n\t                            sub_conds.push([cond, narg]);\n\t                        }\n\t                        final_tokens.push([addrem, componse_cond, key, sub_conds]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            final_tokens.push([SearchType.Include, Cond.Fuzzy, fuzzy_key, str_token]);\n\t        }\n\t    }\n\t    //console.log(JSON.stringify(final_tokens));\n\t    return build_filter_fn_from_tokens(final_tokens);\n\t    var _c;\n\t};\n\texports.build_fn = build_fn;\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// simplesearch.bundle.js","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { test_lib_working } from \"myproj-lib\";\n\nimport { SearchableDataTable } from \"./table\";\n\nclass HWState {\n}\n\nclass HelloWorld extends React.Component<{}, HWState> {\n    constructor(props) {\n        super(props);\n    }\n\n    render() {\n        let docs = [];\n        for (let i = 0; i < 100000; i++) { docs.push({ 'fuzzy': 'hello ' + i, num: i }); }\n        return <SearchableDataTable initDocs={docs} />;\n    }\n}\n\nReactDOM.render(<HelloWorld />,\n    document.getElementById('content'));\n\ntest_lib_working();\n\n\n\n// WEBPACK FOOTER //\n// ./app/simplesearch/src/main.tsx","import { global_dispatcher } from \"./dispatch\";\n\n// Taken directly from `npm install debounce` because it doesn't have clean types.\nfunction debounce(func: Function, wait: number, immediate?: boolean): (Function) => void {\n    function now(): number {\n        return (new Date()).getTime();\n    };\n\n    var timeout, args, context, timestamp, result;\n    if (null == wait) wait = 100;\n\n    function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n            timeout = setTimeout(later, wait - last);\n        } else {\n            timeout = null;\n            if (!immediate) {\n                result = func.apply(context, args);\n                if (!timeout) context = args = null;\n            }\n        }\n    };\n\n    return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n            result = func.apply(context, args);\n            context = args = null;\n        }\n\n        return result;\n    };\n};\n\nfunction ensureValidKeys(state: any, ensureKeys: Array<string>): any {\n    var LOADED_KEY = \"is_loaded\";\n    var return_state: any = {};\n\n    if (state[LOADED_KEY] !== undefined) {\n        throw (\"Cant use `is_loaded` as key in state for ensureValidKeys\");\n    }\n\n    for (var key of ensureKeys) {\n        if (!state[key]) {\n            return { \"is_loaded\": false };\n        }\n        return_state[key] = state[key];\n    }\n\n    return_state[\"is_loaded\"] = true;\n\n    return return_state;\n};\n\nfunction mapMerge(left: any, right: any): any {\n    var new_map = {};\n\n    for (let source of [left, right]) {\n        for (let key of source) {\n            new_map[key] = source[key];\n        }\n    }\n\n    return new_map\n};\n\nfunction test_lib_working() {\n    console.log(\"Lib is working!\");\n}\n\nexport {\n    test_lib_working,\n    ensureValidKeys,\n    global_dispatcher,\n    debounce,\n    mapMerge\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib.tsx","/* \n   Dispatching events isn't as easy as you want it to be.\n\n   While the Dispatcher object (below) is relatively simple, the ruleset\n   that determines what to dispatch is a little more complex.\n\n   In a simple case, a object registers for a simple event:\n\n     global_dispatch.listen('page.tick', mytarget);\n\n   When notify() is called with 'page.tick', the `mytarget` object has its\n   `setState` method called with whatever arg is passed to the notify()\n   method. When the number of 'parts' is equal, this comparison is simple\n   the parts must match (or the search must be a '*').\n\n   Thus, 'page.*' would match 'page.tick', but not 'otherthing.tick'.\n\n   While this would be good enough for most cases, we want to avoid\n   the following.\n\n     // This is what we want to avoid.\n     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n        console.log(\"The ID is: \" + payload.info.id);\n     });\n\n     // dispatch our complex user object.\n     global_dispatch.notify('user.123', {'info':{'id':1}});\n\n     // dispatch a different piece of user data.\n     // This would result in an error.\n     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\n   Instead, since we know the search path, we can dig into the payload\n   object, and return only what the listener asked for.\n\n   Thus, \n\n     // This is what we actually do.\n     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n        console.log(\"The ID is \" + payload.id);\n     });\n\n     // dispatch our complex user object, the above will be called.\n     global_dispatch.notify('user.123', {'info':{'id':1}});\n\n     // dispatch a different piece of user data.\n     // This will not invoke the handler above, because the\n     // route did not match. See `dispatch_object_to_target`\n     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\n   This avoids nasty bugs, and makes sure that your handlers\n   only ever get the data they requested. Handlers can use * at the\n   end of their match in order to get all the keys.\n\n   Keep in mind this only works for events that are dictionaries\n   or objects.\n*/\n\nfunction dispatch_object_to_target(_dispatcher: Dispatcher, event: string,\n    routing_search: string, payload: any,\n    target_fn: any, options: any): any {\n    let sp_event: Array<string> = event.split('.');\n    let sp_search: Array<string> = routing_search.split('.');\n    let final_payload = payload;\n    let routing_path = [];\n    let last_successful_search_part = null;\n\n    for (let index = 0; index < sp_search.length; index++) {\n        let event_part = sp_event[index];\n        let search_part = sp_search[index];\n\n        if (event_part == undefined) {\n            if (search_part == '*') {\n                let new_routing_root = routing_path.join('.');\n                for (let i in final_payload) {\n                    let new_routing = new_routing_root + '.' + i;\n                    console.log(\"new event: \" + new_routing);\n                    _dispatcher.notify(new_routing, final_payload[i]);\n                }\n            } else if (final_payload[search_part] != undefined) {\n                final_payload = final_payload[search_part];\n                last_successful_search_part = search_part;\n                routing_path.push(search_part);\n            } else {\n                return false;\n            }\n        } else if (search_part != '*' && search_part != event_part) {\n            return false;\n        } else {\n            last_successful_search_part = event_part;\n            routing_path.push(event_part);\n        }\n    }\n\n    if (last_successful_search_part != null) {\n        var d = {};\n        d[last_successful_search_part] = final_payload;\n        final_payload = d;\n    }\n\n    return target_fn(final_payload, routing_path.join('.'));\n};\n\n\n// The dispatcher is very similar to the one described in the flux\n// documentation: https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html\n// This dispatcher is intended to be a singleton (but we don't enforce that)\nclass Dispatcher {\n    // A O(n) lookup of listeners, kept in order.\n    listeners: Array<any>;\n\n    // Events that are pending dispatch.\n    event_queue: Array<any>;\n\n    // This helps us keep track of what we are doing and prevents\n    // us from infinite looping (along with the queue).\n    is_dispatching: boolean;\n\n    // is capturing local storage events. We don't need to track this\n    // but it'll make it so more than one call to the method doesn't\n    // wrap the event handler unnessicarily.\n    is_capturing_local_storage_events: boolean;\n\n    // Name of the function on target objects that will be called\n    // whenever we receive a event that object is listening for.\n    function_name: string;\n\n    constructor() {\n        this.listeners = [];\n        this.event_queue = [];\n        this.is_dispatching = false;\n        this.is_capturing_local_storage_events = false;\n        this.function_name = 'setState';\n        this.is_dispatching = false;\n    }\n\n    // Call the `function_name` on the target object. By default\n    // this calls setState (which is the norm for React).\n    listen(routing_key, target, options) {\n        this.listeners.push([routing_key,\n            function () {\n                target.setState(arguments[0]);\n            },\n            options\n        ]);\n    }\n\n    // Listen with a custom function callback.\n    listen_fn(routing_key, target, options) {\n        this.listeners.push([routing_key, target, options]);\n    }\n\n    // Notify listeners that you have data for a key.\n    notify(event_routing_key, args) {\n        if (event_routing_key.indexOf('*') > -1) {\n            throw \"You can't notify with a *; use flush or broadcast.\";\n        }\n        this.event_queue.push([event_routing_key, args]);\n        if (!this.is_dispatching) {\n            this.flush_queue();\n        }\n    }\n\n    // Broadcast an event to all handlers, regardless of their listening key.\n    // This can be used to reset all of your handlers, or to notify them of some\n    // other global change.\n    broadcast(event) {\n        for (let obj of this.listeners) {\n            let fn = obj[1];\n            fn(event, '_');\n        }\n    }\n\n    // Flush will notify any listener that matches a \"startswith\" comparison\n    // Usage in documentation will give more insight into why you might need this.\n    flush(event_routing_key, args) {\n        for (let obj of this.listeners) {\n            let fn = obj[1];\n            let key = obj[0];\n            if (key.substring(0, event_routing_key.length) == event_routing_key) {\n                fn(args, '-');\n            }\n        }\n    }\n\n    flush_queue() {\n        this.is_dispatching = true;\n        // lets preserve the current_event queue.\n        let inner_queue = this.event_queue;\n\n        // and replace it with an empty queue, that way\n        // if events are created during the broadcast of\n        // the following events, we cant get into a\n        // infinite loop.\n        this.event_queue = [];\n\n        while (inner_queue.length) {\n            let item = inner_queue.slice(0, 1)[0];\n            inner_queue = inner_queue.slice(1);\n            this.dispatch_event(item[0], item[1]);\n        }\n\n        if (this.event_queue.length > 0) {\n            // somewhere in the process of dispatching\n            // these events more events came in.\n            // lets give the UI thread a chance to render\n            // and we'll start dispatching again.\n            let _this = this;\n            setTimeout(function () {\n                _this.flush_queue();\n            }, 5);\n        } else {\n            // No other events were created, so we can\n            // gracefully stop. Future calls to notify\n            // will call flush_queue().\n            this.is_dispatching = false;\n        }\n    }\n\n    // The actual work of dispatching a single event.\n    dispatch_event(event_routing_key, args) {\n        let remaining_listeners: Array<any> = [];\n\n        for (let row of this.listeners) {\n            let object_routing: string = row[0];\n            let object_target_fn: any = row[1];\n            let object_options: any = row[2];\n\n            try {\n                // Attempt to dispatch, with some extra rules to dig into objects.\n                dispatch_object_to_target(this,\n                    event_routing_key,\n                    object_routing,\n                    args,\n                    object_target_fn,\n                    object_options);\n\n                // If we make it here, we didn't throw an exception (or we didn't call fn)\n                remaining_listeners.push(row);\n            } catch (e) {\n                console.log('Dropping handler for `' + row[0] + '` on `' +\n                    typeof row[1].constructor + '` because of exception: ' + e);\n            }\n        }\n\n        this.listeners = remaining_listeners;\n    }\n\n    // Warning, this is here to show you how this might work, but it hides\n    // the fact that setItem will clobber complex objects ([], {}) into a\n    // string while adding them to the database.\n    capture_local_storage_changes() {\n        let _this = this;\n        if (this.is_capturing_local_storage_events) {\n            let originalSetItem = localStorage.setItem;\n            localStorage.setItem = function () {\n                originalSetItem.apply(this, arguments);\n                _this.notify(arguments[0], arguments[1]);\n            }\n            this.is_capturing_local_storage_events = true;\n        } else {\n            console.log(\"successive calls to capture_local_storage_changes are ignored.\");\n        }\n    }\n}\n\nlet global_dispatcher = new Dispatcher();\n\nexport { Dispatcher, global_dispatcher };\n\n\n\n// WEBPACK FOOTER //\n// ./src/dispatch.ts","import * as React from \"react\";\nimport { build_fn } from \"./text_to_filter_fun\";\nimport { global_dispatcher, debounce, mapMerge } from \"myproj-lib\";\n\nclass TableState {\n    query_value: string;\n    filterFn: (a: any, b: number, c: any[]) => boolean;\n    items: Array<any>;\n}\n\nclass TableProps {\n    initDocs: Array<any>\n}\n\nclass SearchableDataTable extends React.Component<TableProps, TableState> {\n    constructor(props) {\n        super(props);\n        this.state = {\n            query_value: '',\n            items: this.props.initDocs,\n            filterFn: () => true\n        };\n\n        this.handleChange = this.handleChange.bind(this);\n        this.handleSubmit = this.handleSubmit.bind(this);\n\n        this.handleChange = debounce(this.handleChange, 100);\n    }\n\n    handleChange(event) {\n        let next_state = {\n            query_value: event.target.value,\n            filterFn: build_fn(event.target.value)\n        };\n        this.setState(mapMerge(this.state, next_state));\n    }\n\n    handleSubmit(event) {\n        event.preventDefault();\n    }\n\n    getVisibleItems(): Array<any> {\n        return this.state.items.filter(this.state.filterFn).slice(0, 100);\n    }\n\n    renderRow(item) {\n        return <tr><td>Hello {item.num}</td></tr>;\n    }\n\n    render() {\n        let visibleItems = this.getVisibleItems().map(this.renderRow);\n        return (\n            <div>\n                <form onSubmit={this.handleSubmit}>\n                    <label>Search</label>\n                    <input type=\"text\" value={this.state.query_value} onChange={this.handleChange} />\n                    <input type=\"submit\" value=\"Submit\" />\n                    <div>{visibleItems.length} of {this.state.items.length} items.</div>\n                </form>\n                <table>\n                    {visibleItems}\n                </table>\n            </div>\n        );\n    }\n}\n\nexport {\n    SearchableDataTable\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/simplesearch/src/table.tsx","/* Todo\n\n   - text to conditions.\n   - conditions to text.\n   - better tokens.\n\n*/\n\n\n\n\n/* \n   text_to_filter takes a simple (gmail like) search string and returns\n   a javascript function that accepts one argument, a javascript object,\n   and returns a true or false depending on if that object matches the\n   search string.\n\n   The primary goals are expressiveness and speed, with a secondary goals\n   on readability. This second goal is easy to overcome with macros which\n   allow search criteria rewriting per use (examples below).\n\n   Generated Function -> The function returned by calling build_fn with \n                         some search criteria.\n\n   Item -> Generally refers to the javascript object passed to the\n           generated function.\n\n   Search Type determines if a positive match will include or exclude the\n   item in the search result. Prepending a '\\' or '-' before a condition\n   sets that criteria to exclude, '+' or '/' for include (if neither are\n   present include is assumed).\n */\nenum SearchType {\n    Include,\n    Exclude\n};\n\n\n/* \n   Cond is the basic building block of all our comparisons, more detail\n   inline.\n\n   Where: \n     item  => passed in item.\n     key   => queried key.\n     value => value of argument\n*/\nenum Cond {\n    Exists,             // item[key] != undefined\n    Equal,              // item[key] == value OR item[key](value)\n    NotEqual,           // item[key] != value OR item[key](value)\n    LessThan,           // item[key] < value OR item[key](value)\n    GreaterThan,        // item[key] > value OR item[key](value)\n    ArgValueInItemSeq,  // value in item[key]\n    ItemValueInArgSeq,  // item[key] in value\n    Fuzzy,              // See implementation.\n\n    ComposeOR,          // Composeable OR\n    ComposeAND,         // Composeable AND\n    ComposeNOT          // Composeable NOT (not yet implemented)\n};\n\n\n// Start characters can only be one charater long, may add more here in\n// the future if needed.\nlet cond_lookup = {\n    '=': Cond.Equal,\n    '!': Cond.NotEqual,\n    '>': Cond.GreaterThan,\n    '<': Cond.LessThan,\n    '~': Cond.Fuzzy,\n    '?': Cond.Exists,\n    '$': Cond.ArgValueInItemSeq,\n};\n\n\n// Our cond function lookup.\nlet fn_lookup = {};\n\nfn_lookup[Cond.Equal] = function (value, arg) {\n    return value == arg;\n};\n\nfn_lookup[Cond.NotEqual] = function (value, arg) {\n    return value != arg;\n};\n\nfn_lookup[Cond.LessThan] = function (value, arg) {\n    return value < arg;\n};\n\nfn_lookup[Cond.GreaterThan] = function (value, arg) {\n    return value > arg;\n};\n\nfn_lookup[Cond.Exists] = function (value, arg) {\n    return value !== undefined;\n};\n\nfn_lookup[Cond.ArgValueInItemSeq] = function (value, arg) {\n    return value.indexOf(arg) != -1;\n};\n\nfn_lookup[Cond.ItemValueInArgSeq] = function (value, arg) {\n    return arg.indexOf(value) == -1;\n};\n\nfn_lookup[Cond.Fuzzy] = function (value, arg) {\n    let target_type = typeof (value);\n    if (arg.length == 0) { return false; }\n\n    // Coerce the type if both sides don't match.\n    if (target_type == undefined) {\n        return false;\n    } else if (target_type == \"string\") {\n        return value.search(arg) != -1;\n    } else if (target_type == \"number\") {\n        return (\"\" + value).search(arg) != -1;\n    }\n    return false;\n};\n\n\n// Evaluate the sub parts.\nfn_lookup[Cond.ComposeOR] = function (value, arg) {\n    for (let [cond, narg] of arg) {\n        if (fn_lookup[cond].apply(this, [value, narg])) {\n            return true;\n        }\n    }\n    return false;\n};\n\n\n// Evaluate the sub parts.\nfn_lookup[Cond.ComposeAND] = function (value, arg) {\n    for (let [cond, narg] of arg) {\n        if (fn_lookup[cond].apply(this, [value, narg]) == false) {\n            return false;\n        }\n    }\n    return true;\n};\n\n\n// Tokenize a search in a way that we feel good about.\nlet safe_split = function safe_split(s): Array<any> {\n    var split_char = ' ';\n    let block_chars = {\n        '\"': '\"',\n        \"'\": \"'\",\n        '(': ')',\n        '[': ']',\n        '`': '`'\n    };\n\n    var partitions = [];\n    var current_word = [];\n    var in_block = false;\n    var block_start_char = null;\n\n    for (var i = 0; i < s.length; i++) {\n        var chr = s[i];\n        if (in_block) {\n            if (chr == block_chars[block_start_char]) {\n                current_word.push(chr);\n                in_block = false;\n                block_start_char = null;\n            } else {\n                current_word.push(chr);\n            }\n        } else {\n            if (split_char.indexOf(chr) != -1) {\n                partitions.push(current_word.join(''));\n                current_word = [];\n            } else {\n                if (block_chars[chr] != undefined) {\n                    // we should start a block\n                    in_block = true;\n                    block_start_char = chr;\n                    current_word.push(chr);\n                } else {\n                    current_word.push(chr);\n                }\n            }\n        }\n    }\n\n    if (current_word.length) {\n        partitions.push(current_word.join(''));\n    }\n    return partitions;\n};\n\n\n// Test to see if our token is a condition or just\n// normal text input. `` grave to escape.\nlet is_cond = function (token: string): boolean {\n    if (token.search(':') != -1 && token[0] != '\\`') {\n        return true;\n    }\n    return false;\n};\n\n\n// Parse a cond into it's parts, coerce the value if it\n// makes sense.\nlet cond_parse = function (arg): Array<any> {\n    let cond = Cond.Equal;\n    let str_starts_with = function (key: string, st: string) {\n        if (key.slice(0, st.length) == st) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    for (let key in cond_lookup) {\n        if (str_starts_with(arg, key)) {\n            cond = cond_lookup[key];\n            arg = arg.slice(key.length);\n        }\n    }\n    if (!isNaN(+arg)) {\n        arg = +arg;\n    }\n    if (arg == 't' || arg == 'true') {\n        arg = true;\n    } else if (arg == 'f' || arg == 'false') {\n        arg = false;\n    }\n    return [cond, arg];\n}\n\n\n// Given a set of parsed tokens, build a filter function.\nlet build_filter_fn_from_tokens = function (s: any): any {\n    let conditions = [];\n    for (let outer_item of s) {\n        var lambda = (function (enclosed) {\n            return function (item: any) {\n                let addrem = enclosed[0];\n                let fn_cond_enum = enclosed[1];\n                let key = enclosed[2];\n                let arg = enclosed[3];\n                let ret = false;\n                try {\n                    let key_parts = key.split('.');\n                    let value = item;\n                    if (key_parts.length == 1) {\n                        value = value[key];\n                    } else {\n                        for (let part of key_parts) {\n                            if (value[part] == undefined) {\n                                return false;\n                            }\n                            value = value[part];\n                        }\n                    }\n                    if (typeof value == \"function\") {\n                        if (fn_cond_enum == Cond.Exists) {\n                            ret = true;\n                        } else {\n                            ret = value.apply(item, [arg]);\n                        }\n                    } else if (typeof value == \"undefined\") {\n                        ret = false;\n                    } else {\n                        ret = fn_lookup[fn_cond_enum](value, arg);\n                    }\n                } catch (e) {\n                    console.log(\"Exception in cond: \", fn_lookup[fn_cond_enum]);;\n                    // in light of an exception of a condition,\n                    // we will leave things as they are.\n                }\n                if (addrem == SearchType.Include) {\n                    return ret\n                } else if (addrem == SearchType.Exclude) {\n                    return !ret;\n                } else {\n                    console.log(\"UNKNOWN SEARCH TYPE:\", addrem);\n                    return ret;\n                }\n            };\n        })(outer_item);\n        conditions.push(lambda);\n    }\n    return function (item: any, _index: number, _accum: any[]): any {\n        for (let fn of conditions) {\n            if (fn(item) == false) {\n                return false;\n            }\n        }\n        return true;\n    };\n};\n\n\n// Compose a list of tokens and then use the build_filter_fn_from_tokens\n// to create a function for the user to filter with.\nlet build_fn = function (q: string, options?: {}): any {\n    if (options == undefined) {\n        options = {};\n    }\n\n    let fuzzy_key = options['fuzzy_key'] || 'fuzzy';\n    let macro_map = options['macros'] || {};\n    let final_tokens = [];\n    let basic_tokens = safe_split(q);\n\n    for (let str_token of basic_tokens) {\n        if (is_cond(str_token)) {\n            let addrem = SearchType.Include;\n            let first_char = str_token[0];\n            if (first_char == '-' || first_char == '\\\\') {\n                addrem = SearchType.Exclude;\n                str_token = str_token.slice(1);\n            } else if (first_char == '/' || first_char == '+') {\n                addrem = SearchType.Include;\n                str_token = str_token.slice(1);\n            }\n            let split = str_token.split(':');\n            let key = split[0];\n            for (let arg of split.slice(1)) {\n                if (arg.length > 0) {\n                    if (macro_map[key] != undefined) {\n                        [key, arg] = macro_map[key](key, arg);\n                    }\n                    if (arg.search(',') == -1) {\n                        let [cond, narg] = cond_parse(arg);\n                        final_tokens.push([addrem, cond, key, narg]);\n                    } else {\n                        let componse_cond = Cond.ComposeOR;\n                        if (arg[0] == '&') {\n                            componse_cond = Cond.ComposeAND;\n                            arg = arg.slice(1);\n                        } else if (arg[0] == '|') {\n                            componse_cond = Cond.ComposeOR;\n                            arg = arg.slice(1);\n                        }\n                        let sub_conds = [];\n                        for (let arg_slice of arg.split(',')) {\n                            let [cond, narg] = cond_parse(arg_slice);\n                            sub_conds.push([cond, narg]);\n                        }\n                        final_tokens.push([addrem, componse_cond, key, sub_conds]);\n                    }\n                }\n            }\n        } else {\n            final_tokens.push(\n                [SearchType.Include, Cond.Fuzzy, fuzzy_key, str_token]\n            );\n        }\n    }\n    //console.log(JSON.stringify(final_tokens));\n    return build_filter_fn_from_tokens(final_tokens);\n};\n\nexport {\n    build_fn\n};\n\n\n\n// WEBPACK FOOTER //\n// ./app/simplesearch/src/text_to_filter_fun.ts"],"sourceRoot":""}