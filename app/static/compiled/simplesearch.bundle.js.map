{"version":3,"sources":["webpack:///simplesearch.bundle.js","webpack:///./app/simplesearch/src/main.tsx","webpack:///./src/lib.tsx","webpack:///./src/dispatch.ts","webpack:///./app/simplesearch/src/table.tsx","webpack:///./app/simplesearch/src/text_to_filter_fun.ts"],"names":["webpackJsonp","module","exports","__webpack_require__","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","React","ReactDOM","myproj_lib_1","table_1","HelloWorld","HWState","_super","props","call","render","docs","i","push","fuzzy","num","test","createElement","SearchableDataTable","initDocs","Component","document","getElementById","test_lib_working","debounce","func","wait","immediate","now","Date","getTime","later","last","timestamp","timeout","setTimeout","result","apply","context","args","arguments","callNow","ensureValidKeys","state","ensureKeys","LOADED_KEY","return_state","undefined","_i","ensureKeys_1","length","key","is_loaded","mapMerge","left","right","new_map","_a","source","console","log","dispatch_1","global_dispatcher","dispatch_object_to_target","_dispatcher","event","routing_search","payload","target_fn","options","sp_event","split","sp_search","final_payload","routing_path","last_successful_search_part","index","event_part","search_part","new_routing_root","join","new_routing","notify","Dispatcher","listeners","event_queue","is_dispatching","is_capturing_local_storage_events","function_name","listen","routing_key","target","setState","listen_fn","event_routing_key","indexOf","flush_queue","broadcast","obj","fn","flush","substring","inner_queue","item","slice","dispatch_event","_this_1","remaining_listeners","row","object_routing","object_target_fn","object_options","e","capture_local_storage_changes","_this","originalSetItem_1","localStorage","setItem","text_to_filter_fun_1","TableState","TableProps","query_value","items","filterFn","handleChange","bind","handleSubmit","next_state","value","build_fn","preventDefault","getVisibleItems","filter","renderRow","visibleItems","map","onSubmit","type","onChange","SearchType","Cond","ComposeType","cond_lookup","=","Equal","!","NotEqual",">","GreaterThan","<","LessThan","~","Fuzzy","?","Exists","$","ArgValueInItemSeq","cond_english_lookup","fn_lookup","arg","ItemValueInArgSeq","target_type","search","safe_split","s","split_char","strip_block_chars","block_chars","\"","'","(","[","`","partitions","current_word","in_block","block_start_char","chr","string_to_search_tokens","fuzzy_token","final_tokens","init_tokens","init_tokens_1","tok","arg_list","new_token","gen_token_from_key_args","Include","OR","token_to_english","token","addrem","compose_type","Exclude","AND","new_arg_list","arg_list_1","cond_1","narg","isNaN","dig_key_value","key_parts","key_parts_1","part","q","lambda","condition_fns","_loop_1","outer_token","ret","args_1","fn_cond_enum","final_tokens_1","_index","_accum","condition_fns_1"],"mappings":"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","file":"simplesearch.bundle.js","sourcesContent":["webpackJsonp([2],[\n/* 0 */\n/*!***************************************!*\\\n  !*** ./app/simplesearch/src/main.tsx ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar React = __webpack_require__(/*! react */ 1);\n\tvar ReactDOM = __webpack_require__(/*! react-dom */ 1);\n\tvar myproj_lib_1 = __webpack_require__(/*! myproj-lib */ 5);\n\tvar table_1 = __webpack_require__(/*! ./table */ 7);\n\tvar HWState = (function () {\n\t    function HWState() {\n\t    }\n\t    return HWState;\n\t}());\n\tvar HelloWorld = (function (_super) {\n\t    __extends(HelloWorld, _super);\n\t    function HelloWorld(props) {\n\t        _super.call(this, props);\n\t    }\n\t    HelloWorld.prototype.render = function () {\n\t        var docs = [];\n\t        for (var i = 0; i < 20; i++) {\n\t            docs.push({ 'fuzzy': 'hello ' + i, num: i, 'test': function () { return true; } });\n\t        }\n\t        return React.createElement(table_1.SearchableDataTable, {initDocs: docs});\n\t    };\n\t    return HelloWorld;\n\t}(React.Component));\n\tReactDOM.render(React.createElement(HelloWorld, null), document.getElementById('content'));\n\tmyproj_lib_1.test_lib_working();\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/*!*********************!*\\\n  !*** ./src/lib.tsx ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar dispatch_1 = __webpack_require__(/*! ./dispatch */ 6);\n\texports.global_dispatcher = dispatch_1.global_dispatcher;\n\t// Taken directly from `npm install debounce` because it doesn't have clean types.\n\tfunction debounce(func, wait, immediate) {\n\t    function now() {\n\t        return (new Date()).getTime();\n\t    }\n\t    ;\n\t    var timeout, args, context, timestamp, result;\n\t    if (null == wait)\n\t        wait = 100;\n\t    function later() {\n\t        var last = now() - timestamp;\n\t        if (last < wait && last > 0) {\n\t            timeout = setTimeout(later, wait - last);\n\t        }\n\t        else {\n\t            timeout = null;\n\t            if (!immediate) {\n\t                result = func.apply(context, args);\n\t                if (!timeout)\n\t                    context = args = null;\n\t            }\n\t        }\n\t    }\n\t    ;\n\t    return function debounced() {\n\t        context = this;\n\t        args = arguments;\n\t        timestamp = now();\n\t        var callNow = immediate && !timeout;\n\t        if (!timeout)\n\t            timeout = setTimeout(later, wait);\n\t        if (callNow) {\n\t            result = func.apply(context, args);\n\t            context = args = null;\n\t        }\n\t        return result;\n\t    };\n\t}\n\texports.debounce = debounce;\n\t;\n\tfunction ensureValidKeys(state, ensureKeys) {\n\t    var LOADED_KEY = \"is_loaded\";\n\t    var return_state = {};\n\t    if (state[LOADED_KEY] !== undefined) {\n\t        throw (\"Cant use `is_loaded` as key in state for ensureValidKeys\");\n\t    }\n\t    for (var _i = 0, ensureKeys_1 = ensureKeys; _i < ensureKeys_1.length; _i++) {\n\t        var key = ensureKeys_1[_i];\n\t        if (!state[key]) {\n\t            return { \"is_loaded\": false };\n\t        }\n\t        return_state[key] = state[key];\n\t    }\n\t    return_state[\"is_loaded\"] = true;\n\t    return return_state;\n\t}\n\texports.ensureValidKeys = ensureValidKeys;\n\t;\n\tfunction mapMerge(left, right) {\n\t    var new_map = {};\n\t    for (var _i = 0, _a = [left, right]; _i < _a.length; _i++) {\n\t        var source = _a[_i];\n\t        for (var key in source) {\n\t            new_map[key] = source[key];\n\t        }\n\t    }\n\t    return new_map;\n\t}\n\texports.mapMerge = mapMerge;\n\t;\n\tfunction test_lib_working() {\n\t    console.log(\"Lib is working!\");\n\t}\n\texports.test_lib_working = test_lib_working;\n\n\n/***/ },\n/* 6 */\n/*!*************************!*\\\n  !*** ./src/dispatch.ts ***!\n  \\*************************/\n/***/ function(module, exports) {\n\n\t/*\n\t   Dispatching events isn't as easy as you want it to be.\n\t\n\t   While the Dispatcher object (below) is relatively simple, the ruleset\n\t   that determines what to dispatch is a little more complex.\n\t\n\t   In a simple case, a object registers for a simple event:\n\t\n\t     global_dispatch.listen('page.tick', mytarget);\n\t\n\t   When notify() is called with 'page.tick', the `mytarget` object has its\n\t   `setState` method called with whatever arg is passed to the notify()\n\t   method. When the number of 'parts' is equal, this comparison is simple\n\t   the parts must match (or the search must be a '*').\n\t\n\t   Thus, 'page.*' would match 'page.tick', but not 'otherthing.tick'.\n\t\n\t   While this would be good enough for most cases, we want to avoid\n\t   the following.\n\t\n\t     // This is what we want to avoid.\n\t     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n\t        console.log(\"The ID is: \" + payload.info.id);\n\t     });\n\t\n\t     // dispatch our complex user object.\n\t     global_dispatch.notify('user.123', {'info':{'id':1}});\n\t\n\t     // dispatch a different piece of user data.\n\t     // This would result in an error.\n\t     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\t\n\t   Instead, since we know the search path, we can dig into the payload\n\t   object, and return only what the listener asked for.\n\t\n\t   Thus,\n\t\n\t     // This is what we actually do.\n\t     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n\t        console.log(\"The ID is \" + payload.id);\n\t     });\n\t\n\t     // dispatch our complex user object, the above will be called.\n\t     global_dispatch.notify('user.123', {'info':{'id':1}});\n\t\n\t     // dispatch a different piece of user data.\n\t     // This will not invoke the handler above, because the\n\t     // route did not match. See `dispatch_object_to_target`\n\t     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\t\n\t   This avoids nasty bugs, and makes sure that your handlers\n\t   only ever get the data they requested. Handlers can use * at the\n\t   end of their match in order to get all the keys.\n\t\n\t   Keep in mind this only works for events that are dictionaries\n\t   or objects.\n\t*/\n\t\"use strict\";\n\tfunction dispatch_object_to_target(_dispatcher, event, routing_search, payload, target_fn, options) {\n\t    var sp_event = event.split('.');\n\t    var sp_search = routing_search.split('.');\n\t    var final_payload = payload;\n\t    var routing_path = [];\n\t    var last_successful_search_part = null;\n\t    for (var index = 0; index < sp_search.length; index++) {\n\t        var event_part = sp_event[index];\n\t        var search_part = sp_search[index];\n\t        if (event_part == undefined) {\n\t            if (search_part == '*') {\n\t                var new_routing_root = routing_path.join('.');\n\t                for (var i in final_payload) {\n\t                    var new_routing = new_routing_root + '.' + i;\n\t                    console.log(\"new event: \" + new_routing);\n\t                    _dispatcher.notify(new_routing, final_payload[i]);\n\t                }\n\t            }\n\t            else if (final_payload[search_part] != undefined) {\n\t                final_payload = final_payload[search_part];\n\t                last_successful_search_part = search_part;\n\t                routing_path.push(search_part);\n\t            }\n\t            else {\n\t                return false;\n\t            }\n\t        }\n\t        else if (search_part != '*' && search_part != event_part) {\n\t            return false;\n\t        }\n\t        else {\n\t            last_successful_search_part = event_part;\n\t            routing_path.push(event_part);\n\t        }\n\t    }\n\t    if (last_successful_search_part != null) {\n\t        var d = {};\n\t        d[last_successful_search_part] = final_payload;\n\t        final_payload = d;\n\t    }\n\t    return target_fn(final_payload, routing_path.join('.'));\n\t}\n\t;\n\t// The dispatcher is very similar to the one described in the flux\n\t// documentation: https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html\n\t// This dispatcher is intended to be a singleton (but we don't enforce that)\n\tvar Dispatcher = (function () {\n\t    function Dispatcher() {\n\t        this.listeners = [];\n\t        this.event_queue = [];\n\t        this.is_dispatching = false;\n\t        this.is_capturing_local_storage_events = false;\n\t        this.function_name = 'setState';\n\t        this.is_dispatching = false;\n\t    }\n\t    // Call the `function_name` on the target object. By default\n\t    // this calls setState (which is the norm for React).\n\t    Dispatcher.prototype.listen = function (routing_key, target, options) {\n\t        this.listeners.push([routing_key,\n\t            function () {\n\t                target.setState(arguments[0]);\n\t            },\n\t            options\n\t        ]);\n\t    };\n\t    // Listen with a custom function callback.\n\t    Dispatcher.prototype.listen_fn = function (routing_key, target, options) {\n\t        this.listeners.push([routing_key, target, options]);\n\t    };\n\t    // Notify listeners that you have data for a key.\n\t    Dispatcher.prototype.notify = function (event_routing_key, args) {\n\t        if (event_routing_key.indexOf('*') > -1) {\n\t            throw \"You can't notify with a *; use flush or broadcast.\";\n\t        }\n\t        this.event_queue.push([event_routing_key, args]);\n\t        if (!this.is_dispatching) {\n\t            this.flush_queue();\n\t        }\n\t    };\n\t    // Broadcast an event to all handlers, regardless of their listening key.\n\t    // This can be used to reset all of your handlers, or to notify them of some\n\t    // other global change.\n\t    Dispatcher.prototype.broadcast = function (event) {\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var obj = _a[_i];\n\t            var fn = obj[1];\n\t            fn(event, '_');\n\t        }\n\t    };\n\t    // Flush will notify any listener that matches a \"startswith\" comparison\n\t    // Usage in documentation will give more insight into why you might need this.\n\t    Dispatcher.prototype.flush = function (event_routing_key, args) {\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var obj = _a[_i];\n\t            var fn = obj[1];\n\t            var key = obj[0];\n\t            if (key.substring(0, event_routing_key.length) == event_routing_key) {\n\t                fn(args, '-');\n\t            }\n\t        }\n\t    };\n\t    Dispatcher.prototype.flush_queue = function () {\n\t        this.is_dispatching = true;\n\t        // lets preserve the current_event queue.\n\t        var inner_queue = this.event_queue;\n\t        // and replace it with an empty queue, that way\n\t        // if events are created during the broadcast of\n\t        // the following events, we cant get into a\n\t        // infinite loop.\n\t        this.event_queue = [];\n\t        while (inner_queue.length) {\n\t            var item = inner_queue.slice(0, 1)[0];\n\t            inner_queue = inner_queue.slice(1);\n\t            this.dispatch_event(item[0], item[1]);\n\t        }\n\t        if (this.event_queue.length > 0) {\n\t            // somewhere in the process of dispatching\n\t            // these events more events came in.\n\t            // lets give the UI thread a chance to render\n\t            // and we'll start dispatching again.\n\t            var _this_1 = this;\n\t            setTimeout(function () {\n\t                _this_1.flush_queue();\n\t            }, 5);\n\t        }\n\t        else {\n\t            // No other events were created, so we can\n\t            // gracefully stop. Future calls to notify\n\t            // will call flush_queue().\n\t            this.is_dispatching = false;\n\t        }\n\t    };\n\t    // The actual work of dispatching a single event.\n\t    Dispatcher.prototype.dispatch_event = function (event_routing_key, args) {\n\t        var remaining_listeners = [];\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var row = _a[_i];\n\t            var object_routing = row[0];\n\t            var object_target_fn = row[1];\n\t            var object_options = row[2];\n\t            try {\n\t                // Attempt to dispatch, with some extra rules to dig into objects.\n\t                dispatch_object_to_target(this, event_routing_key, object_routing, args, object_target_fn, object_options);\n\t                // If we make it here, we didn't throw an exception (or we didn't call fn)\n\t                remaining_listeners.push(row);\n\t            }\n\t            catch (e) {\n\t                console.log('Dropping handler for `' + row[0] + '` on `' +\n\t                    typeof row[1].constructor + '` because of exception: ' + e);\n\t            }\n\t        }\n\t        this.listeners = remaining_listeners;\n\t    };\n\t    // Warning, this is here to show you how this might work, but it hides\n\t    // the fact that setItem will clobber complex objects ([], {}) into a\n\t    // string while adding them to the database.\n\t    Dispatcher.prototype.capture_local_storage_changes = function () {\n\t        var _this = this;\n\t        if (this.is_capturing_local_storage_events) {\n\t            var originalSetItem_1 = localStorage.setItem;\n\t            localStorage.setItem = function () {\n\t                originalSetItem_1.apply(this, arguments);\n\t                _this.notify(arguments[0], arguments[1]);\n\t            };\n\t            this.is_capturing_local_storage_events = true;\n\t        }\n\t        else {\n\t            console.log(\"successive calls to capture_local_storage_changes are ignored.\");\n\t        }\n\t    };\n\t    return Dispatcher;\n\t}());\n\texports.Dispatcher = Dispatcher;\n\tvar global_dispatcher = new Dispatcher();\n\texports.global_dispatcher = global_dispatcher;\n\n\n/***/ },\n/* 7 */\n/*!****************************************!*\\\n  !*** ./app/simplesearch/src/table.tsx ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar React = __webpack_require__(/*! react */ 1);\n\tvar text_to_filter_fun_1 = __webpack_require__(/*! ./text_to_filter_fun */ 8);\n\tvar myproj_lib_1 = __webpack_require__(/*! myproj-lib */ 5);\n\tvar TableState = (function () {\n\t    function TableState() {\n\t    }\n\t    return TableState;\n\t}());\n\tvar TableProps = (function () {\n\t    function TableProps() {\n\t    }\n\t    return TableProps;\n\t}());\n\tvar SearchableDataTable = (function (_super) {\n\t    __extends(SearchableDataTable, _super);\n\t    function SearchableDataTable(props) {\n\t        _super.call(this, props);\n\t        this.state = {\n\t            query_value: '',\n\t            items: this.props.initDocs,\n\t            filterFn: function () { return true; }\n\t        };\n\t        this.handleChange = this.handleChange.bind(this);\n\t        this.handleSubmit = this.handleSubmit.bind(this);\n\t        this.handleChange = myproj_lib_1.debounce(this.handleChange, 100);\n\t    }\n\t    SearchableDataTable.prototype.handleChange = function (event) {\n\t        var next_state = {\n\t            query_value: event.target.value,\n\t            filterFn: text_to_filter_fun_1.build_fn(event.target.value)\n\t        };\n\t        this.setState(myproj_lib_1.mapMerge(this.state, next_state));\n\t    };\n\t    SearchableDataTable.prototype.handleSubmit = function (event) {\n\t        event.preventDefault();\n\t    };\n\t    SearchableDataTable.prototype.getVisibleItems = function () {\n\t        return this.state.items.filter(this.state.filterFn).slice(0, 100);\n\t    };\n\t    SearchableDataTable.prototype.renderRow = function (item) {\n\t        return React.createElement(\"tr\", null, \n\t            React.createElement(\"td\", null, \n\t                \"Hello \", \n\t                item.num, \n\t                \" \", \n\t                item.fuzzy)\n\t        );\n\t    };\n\t    SearchableDataTable.prototype.render = function () {\n\t        var visibleItems = this.getVisibleItems().map(this.renderRow);\n\t        return (React.createElement(\"div\", null, \n\t            React.createElement(\"form\", {onSubmit: this.handleSubmit}, \n\t                React.createElement(\"label\", null, \"Search\"), \n\t                React.createElement(\"input\", {type: \"text\", value: this.state.query_value, onChange: this.handleChange}), \n\t                React.createElement(\"input\", {type: \"submit\", value: \"Submit\"}), \n\t                React.createElement(\"div\", null, \n\t                    visibleItems.length, \n\t                    \" of \", \n\t                    this.state.items.length, \n\t                    \" items.\")), \n\t            React.createElement(\"table\", null, visibleItems)));\n\t    };\n\t    return SearchableDataTable;\n\t}(React.Component));\n\texports.SearchableDataTable = SearchableDataTable;\n\n\n/***/ },\n/* 8 */\n/*!****************************************************!*\\\n  !*** ./app/simplesearch/src/text_to_filter_fun.ts ***!\n  \\****************************************************/\n/***/ function(module, exports) {\n\n\t/*\n\t   text_to_filter takes a simple (gmail like) search string and returns\n\t   a javascript function that accepts one argument, a javascript object,\n\t   and returns a true or false depending on if that object matches the\n\t   search string.\n\t\n\t   The primary goals are expressiveness and speed, with a secondary goals\n\t   on readability. This second goal is easy to overcome with macros which\n\t   allow search criteria rewriting per use (examples below).\n\t\n\t   Generated Function -> The function returned by calling build_fn with\n\t                         some search criteria.\n\t\n\t   Item -> Generally refers to the javascript object passed to the\n\t           generated function.\n\t\n\t   Search Type determines if a positive match will include or exclude the\n\t   item in the search result. Prepending a '\\' or '-' before a condition\n\t   sets that criteria to exclude, '+' or '/' for include (if neither are\n\t   present include is assumed).\n\t */\n\t\"use strict\";\n\tvar SearchType;\n\t(function (SearchType) {\n\t    SearchType[SearchType[\"Include\"] = 0] = \"Include\";\n\t    SearchType[SearchType[\"Exclude\"] = 1] = \"Exclude\";\n\t})(SearchType || (SearchType = {}));\n\t;\n\t/*\n\t   Cond is the basic building block of all our comparisons, more detail\n\t   inline.\n\t\n\t   Where:\n\t     item  => passed in item.\n\t     key   => queried key.\n\t     value => value of argument\n\t*/\n\tvar Cond;\n\t(function (Cond) {\n\t    Cond[Cond[\"Exists\"] = 0] = \"Exists\";\n\t    Cond[Cond[\"Equal\"] = 1] = \"Equal\";\n\t    Cond[Cond[\"NotEqual\"] = 2] = \"NotEqual\";\n\t    Cond[Cond[\"LessThan\"] = 3] = \"LessThan\";\n\t    Cond[Cond[\"GreaterThan\"] = 4] = \"GreaterThan\";\n\t    Cond[Cond[\"ArgValueInItemSeq\"] = 5] = \"ArgValueInItemSeq\";\n\t    Cond[Cond[\"ItemValueInArgSeq\"] = 6] = \"ItemValueInArgSeq\";\n\t    Cond[Cond[\"Fuzzy\"] = 7] = \"Fuzzy\"; // See implementation.\n\t})(Cond || (Cond = {}));\n\t;\n\t/*\n\t   Composition types are part of every query,\n\t   determines how the set of conditions will be evaluated.\n\t*/\n\tvar ComposeType;\n\t(function (ComposeType) {\n\t    ComposeType[ComposeType[\"OR\"] = 0] = \"OR\";\n\t    ComposeType[ComposeType[\"AND\"] = 1] = \"AND\";\n\t    ComposeType[ComposeType[\"NAND\"] = 2] = \"NAND\";\n\t    ComposeType[ComposeType[\"XOR\"] = 3] = \"XOR\"; // Composeable XOR\n\t})(ComposeType || (ComposeType = {}));\n\t;\n\t// Start characters can only be one charater long, may add more here in\n\t// the future if needed.\n\tvar cond_lookup = {\n\t    '=': Cond.Equal,\n\t    '!': Cond.NotEqual,\n\t    '>': Cond.GreaterThan,\n\t    '<': Cond.LessThan,\n\t    '~': Cond.Fuzzy,\n\t    '?': Cond.Exists,\n\t    '$': Cond.ArgValueInItemSeq\n\t};\n\tvar cond_english_lookup = {};\n\tfor (var key in cond_lookup) {\n\t    cond_english_lookup[cond_lookup[key]] = key;\n\t}\n\t// Our cond function lookup.\n\tvar fn_lookup = {};\n\tfn_lookup[Cond.Equal] = function (value, arg) {\n\t    return value == arg;\n\t};\n\tfn_lookup[Cond.NotEqual] = function (value, arg) {\n\t    return value != arg;\n\t};\n\tfn_lookup[Cond.LessThan] = function (value, arg) {\n\t    return value < arg;\n\t};\n\tfn_lookup[Cond.GreaterThan] = function (value, arg) {\n\t    return value > arg;\n\t};\n\tfn_lookup[Cond.Exists] = function (value, arg) {\n\t    return value !== undefined;\n\t};\n\tfn_lookup[Cond.ArgValueInItemSeq] = function (value, arg) {\n\t    return value.indexOf(arg) != -1;\n\t};\n\tfn_lookup[Cond.ItemValueInArgSeq] = function (value, arg) {\n\t    return arg.indexOf(value) == -1;\n\t};\n\tfn_lookup[Cond.Fuzzy] = function (value, arg) {\n\t    var target_type = typeof (value);\n\t    if (arg.length == 0) {\n\t        return false;\n\t    }\n\t    // Coerce the type if both sides don't match.\n\t    if (target_type == undefined) {\n\t        return false;\n\t    }\n\t    else if (target_type == \"string\") {\n\t        return value.search(arg) != -1;\n\t    }\n\t    else if (target_type == \"number\") {\n\t        return (\"\" + value).search(arg) != -1;\n\t    }\n\t    return false;\n\t};\n\t// Tokenize a search in a way that we feel good about.\n\tvar safe_split = function safe_split(s, split_char, strip_block_chars) {\n\t    if (strip_block_chars == undefined) {\n\t        strip_block_chars = false;\n\t    }\n\t    var block_chars = {\n\t        '\"': '\"',\n\t        \"'\": \"'\",\n\t        '(': ')',\n\t        '[': ']',\n\t        '`': '`'\n\t    };\n\t    var partitions = [];\n\t    var current_word = [];\n\t    var in_block = false;\n\t    var block_start_char = null;\n\t    for (var i = 0; i < s.length; i++) {\n\t        var chr = s[i];\n\t        if (in_block) {\n\t            if (chr == block_chars[block_start_char]) {\n\t                if (!strip_block_chars) {\n\t                    current_word.push(chr);\n\t                }\n\t                in_block = false;\n\t                block_start_char = null;\n\t            }\n\t            else {\n\t                current_word.push(chr);\n\t            }\n\t        }\n\t        else {\n\t            if (split_char.indexOf(chr) != -1) {\n\t                partitions.push(current_word.join(''));\n\t                current_word = [];\n\t            }\n\t            else {\n\t                if (block_chars[chr] != undefined) {\n\t                    // we should start a block\n\t                    in_block = true;\n\t                    block_start_char = chr;\n\t                    if (!strip_block_chars) {\n\t                        current_word.push(chr);\n\t                    }\n\t                }\n\t                else {\n\t                    current_word.push(chr);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if (current_word.length) {\n\t        partitions.push(current_word.join(''));\n\t    }\n\t    return partitions;\n\t};\n\t// Create a set of search tokens given a search query.\n\tvar string_to_search_tokens = function (s) {\n\t    var fuzzy_token = [];\n\t    var final_tokens = [];\n\t    var init_tokens = safe_split(s, ' ');\n\t    for (var _i = 0, init_tokens_1 = init_tokens; _i < init_tokens_1.length; _i++) {\n\t        var tok = init_tokens_1[_i];\n\t        var index = tok.search(':');\n\t        if (index == -1) {\n\t            fuzzy_token.push([Cond.Fuzzy, tok]);\n\t        }\n\t        else {\n\t            var key = tok.slice(0, index);\n\t            var arg_list = safe_split(tok.slice(index + 1), ',', true);\n\t            var new_token = gen_token_from_key_args(key, arg_list);\n\t            if (new_token) {\n\t                final_tokens.push(new_token);\n\t            }\n\t        }\n\t    }\n\t    final_tokens.push([SearchType.Include, 'fuzzy', ComposeType.OR, fuzzy_token]);\n\t    return final_tokens;\n\t};\n\texports.string_to_search_tokens = string_to_search_tokens;\n\t// Convert a token to something readable by a human.\n\tvar token_to_english = function (token) {\n\t    var addrem = token[0], key = token[1], compose_type = token[2], args = token[3];\n\t    var s = [];\n\t    // Search Type\n\t    s.push(SearchType[addrem]);\n\t    s.push(\"results where \" + key + \" matches\");\n\t    s.push(args.map(function (arg) {\n\t        return ' ' + Cond[arg[0]] + ' |' + arg[1] + '| ';\n\t    }).join(ComposeType[compose_type]));\n\t    return s.join(' ');\n\t};\n\texports.token_to_english = token_to_english;\n\t// Convert a token back to a safe query value.\n\tvar token_to_query = function (token) {\n\t    var addrem = token[0], key = token[1], compose_type = token[2], args = token[3];\n\t    var s = [];\n\t    if (addrem == SearchType.Include) {\n\t    }\n\t    else if (addrem == SearchType.Exclude) {\n\t        s.push('-');\n\t    }\n\t    s.push(key);\n\t    s.push(':');\n\t    if (compose_type == ComposeType.AND) {\n\t        s.push('&,');\n\t    }\n\t    s.push(args.map(function (arg) {\n\t        return \"`\" + cond_english_lookup[arg[0]] + arg[1] + \"`\";\n\t    }).join(','));\n\t    return s.join('');\n\t};\n\t// Generate a token for a given key and it's arguments.\n\tvar gen_token_from_key_args = function (key, arg_list) {\n\t    // Determine if this search is inclusive or exclusive.\n\t    var addrem = SearchType.Include;\n\t    var cond = Cond.Equal;\n\t    var compose_type = ComposeType.OR;\n\t    if (key[0] == '-') {\n\t        addrem = SearchType.Exclude;\n\t        key = key.slice(1);\n\t    }\n\t    else if (key[0] == '+') {\n\t        addrem = SearchType.Include;\n\t        key = key.slice(1);\n\t    }\n\t    if (arg_list.length == 0) {\n\t        return null;\n\t    }\n\t    if (arg_list[0] == '&') {\n\t        compose_type = ComposeType.AND;\n\t        arg_list = arg_list.slice(1);\n\t    }\n\t    var new_arg_list = [];\n\t    for (var _i = 0, arg_list_1 = arg_list; _i < arg_list_1.length; _i++) {\n\t        var arg = arg_list_1[_i];\n\t        var cond_1 = Cond.Equal;\n\t        var narg = arg;\n\t        if (cond_lookup.hasOwnProperty(arg[0])) {\n\t            cond_1 = cond_lookup[arg[0]];\n\t            narg = arg.slice(1);\n\t        }\n\t        if (!isNaN(+narg)) {\n\t            narg = +narg;\n\t        }\n\t        if (narg == 't' || narg == 'true') {\n\t            narg = true;\n\t        }\n\t        else if (narg == 'f' || narg == 'false') {\n\t            narg = false;\n\t        }\n\t        new_arg_list.push([cond_1, narg]);\n\t    }\n\t    var new_token = [\n\t        addrem,\n\t        key,\n\t        compose_type,\n\t        new_arg_list\n\t    ];\n\t    return new_token;\n\t};\n\t// If a key is referencing nested data, retrieve it.\n\tvar dig_key_value = function (key, value) {\n\t    var key_parts = key.split('.');\n\t    if (key_parts.length == 1) {\n\t        return value[key];\n\t    }\n\t    else {\n\t        for (var _i = 0, key_parts_1 = key_parts; _i < key_parts_1.length; _i++) {\n\t            var part = key_parts_1[_i];\n\t            if (value[part] == undefined) {\n\t                return undefined;\n\t            }\n\t            value = value[part];\n\t        }\n\t    }\n\t    return value;\n\t};\n\t// Compose a list of tokens and then use the build_filter_fn_from_tokens\n\t// to create a function for the user to filter with.\n\tvar build_fn = function (q, options) {\n\t    if (options == undefined) {\n\t        options = {};\n\t    }\n\t    var fuzzy_key = options['fuzzy_key'] || 'fuzzy';\n\t    var macro_map = options['macros'] || {};\n\t    var final_tokens = string_to_search_tokens(q);\n\t    var condition_fns = [];\n\t    var _loop_1 = function(outer_token) {\n\t        lambda = function (item) {\n\t            var ret = true;\n\t            var addrem = outer_token[0], key = outer_token[1], compose_type = outer_token[2], args = outer_token[3];\n\t            var value = dig_key_value(key, item);\n\t            for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n\t                var arg = args_1[_i];\n\t                var fn_cond_enum = arg[0];\n\t                try {\n\t                    if (typeof value == \"function\") {\n\t                        if (fn_cond_enum == Cond.Exists) {\n\t                            ret = true;\n\t                        }\n\t                        else {\n\t                            ret = value.apply(item, [arg[1]]);\n\t                        }\n\t                    }\n\t                    else if (typeof value == \"undefined\") {\n\t                        ret = false;\n\t                    }\n\t                    else {\n\t                        ret = fn_lookup[fn_cond_enum](value, arg[1]);\n\t                    }\n\t                }\n\t                catch (e) {\n\t                    console.log(\"Exception in cond: \", fn_lookup[fn_cond_enum]);\n\t                    ;\n\t                    ret = true;\n\t                }\n\t                if (addrem == SearchType.Include) {\n\t                }\n\t                else if (addrem == SearchType.Exclude) {\n\t                    ret = !ret;\n\t                }\n\t                if (compose_type == ComposeType.OR && ret == true) {\n\t                    return true;\n\t                }\n\t                else if (compose_type == ComposeType.AND && ret == false) {\n\t                    return false;\n\t                }\n\t            }\n\t            return ret;\n\t        };\n\t        condition_fns.push(lambda);\n\t    };\n\t    var lambda;\n\t    for (var _i = 0, final_tokens_1 = final_tokens; _i < final_tokens_1.length; _i++) {\n\t        var outer_token = final_tokens_1[_i];\n\t        _loop_1(outer_token);\n\t    }\n\t    //console.log(JSON.stringify(final_tokens));\n\t    return function (item, _index, _accum) {\n\t        for (var _i = 0, condition_fns_1 = condition_fns; _i < condition_fns_1.length; _i++) {\n\t            var fn = condition_fns_1[_i];\n\t            if (fn(item) == false) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t};\n\texports.build_fn = build_fn;\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// simplesearch.bundle.js","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { test_lib_working } from \"myproj-lib\";\n\nimport { SearchableDataTable } from \"./table\";\nimport { TokenDataTable } from \"./token_table\";\n\nclass HWState {\n}\n\nclass HelloWorld extends React.Component<{}, HWState> {\n    constructor(props) {\n        super(props);\n    }\n\n    render() {\n        let docs = [];\n        for (let i = 0; i < 20; i++) { docs.push({ 'fuzzy': 'hello ' + i, num: i, 'test': function () { return true; } }); }\n        return <SearchableDataTable initDocs={docs} />\n    }\n}\n\nReactDOM.render(<HelloWorld />,\n    document.getElementById('content'));\n\ntest_lib_working();\n\n\n\n// WEBPACK FOOTER //\n// ./app/simplesearch/src/main.tsx","import { global_dispatcher } from \"./dispatch\";\n\n// Taken directly from `npm install debounce` because it doesn't have clean types.\nfunction debounce(func: Function, wait: number, immediate?: boolean): (Function) => void {\n    function now(): number {\n        return (new Date()).getTime();\n    };\n\n    var timeout, args, context, timestamp, result;\n    if (null == wait) wait = 100;\n\n    function later() {\n        var last = now() - timestamp;\n\n        if (last < wait && last > 0) {\n            timeout = setTimeout(later, wait - last);\n        } else {\n            timeout = null;\n            if (!immediate) {\n                result = func.apply(context, args);\n                if (!timeout) context = args = null;\n            }\n        }\n    };\n\n    return function debounced() {\n        context = this;\n        args = arguments;\n        timestamp = now();\n        var callNow = immediate && !timeout;\n        if (!timeout) timeout = setTimeout(later, wait);\n        if (callNow) {\n            result = func.apply(context, args);\n            context = args = null;\n        }\n\n        return result;\n    };\n};\n\nfunction ensureValidKeys(state: any, ensureKeys: Array<string>): any {\n    var LOADED_KEY = \"is_loaded\";\n    var return_state: any = {};\n\n    if (state[LOADED_KEY] !== undefined) {\n        throw (\"Cant use `is_loaded` as key in state for ensureValidKeys\");\n    }\n\n    for (var key of ensureKeys) {\n        if (!state[key]) {\n            return { \"is_loaded\": false };\n        }\n        return_state[key] = state[key];\n    }\n\n    return_state[\"is_loaded\"] = true;\n\n    return return_state;\n};\n\nfunction mapMerge(left: any, right: any): any {\n    var new_map = {};\n\n    for (let source of [left, right]) {\n        for (let key in source) {\n            new_map[key] = source[key];\n        }\n    }\n\n    return new_map\n};\n\nfunction test_lib_working() {\n    console.log(\"Lib is working!\");\n}\n\nexport {\n    test_lib_working,\n    ensureValidKeys,\n    global_dispatcher,\n    debounce,\n    mapMerge\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib.tsx","/* \n   Dispatching events isn't as easy as you want it to be.\n\n   While the Dispatcher object (below) is relatively simple, the ruleset\n   that determines what to dispatch is a little more complex.\n\n   In a simple case, a object registers for a simple event:\n\n     global_dispatch.listen('page.tick', mytarget);\n\n   When notify() is called with 'page.tick', the `mytarget` object has its\n   `setState` method called with whatever arg is passed to the notify()\n   method. When the number of 'parts' is equal, this comparison is simple\n   the parts must match (or the search must be a '*').\n\n   Thus, 'page.*' would match 'page.tick', but not 'otherthing.tick'.\n\n   While this would be good enough for most cases, we want to avoid\n   the following.\n\n     // This is what we want to avoid.\n     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n        console.log(\"The ID is: \" + payload.info.id);\n     });\n\n     // dispatch our complex user object.\n     global_dispatch.notify('user.123', {'info':{'id':1}});\n\n     // dispatch a different piece of user data.\n     // This would result in an error.\n     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\n   Instead, since we know the search path, we can dig into the payload\n   object, and return only what the listener asked for.\n\n   Thus, \n\n     // This is what we actually do.\n     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n        console.log(\"The ID is \" + payload.id);\n     });\n\n     // dispatch our complex user object, the above will be called.\n     global_dispatch.notify('user.123', {'info':{'id':1}});\n\n     // dispatch a different piece of user data.\n     // This will not invoke the handler above, because the\n     // route did not match. See `dispatch_object_to_target`\n     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\n   This avoids nasty bugs, and makes sure that your handlers\n   only ever get the data they requested. Handlers can use * at the\n   end of their match in order to get all the keys.\n\n   Keep in mind this only works for events that are dictionaries\n   or objects.\n*/\n\nfunction dispatch_object_to_target(_dispatcher: Dispatcher, event: string,\n    routing_search: string, payload: any,\n    target_fn: any, options: any): any {\n    let sp_event: Array<string> = event.split('.');\n    let sp_search: Array<string> = routing_search.split('.');\n    let final_payload = payload;\n    let routing_path = [];\n    let last_successful_search_part = null;\n\n    for (let index = 0; index < sp_search.length; index++) {\n        let event_part = sp_event[index];\n        let search_part = sp_search[index];\n\n        if (event_part == undefined) {\n            if (search_part == '*') {\n                let new_routing_root = routing_path.join('.');\n                for (let i in final_payload) {\n                    let new_routing = new_routing_root + '.' + i;\n                    console.log(\"new event: \" + new_routing);\n                    _dispatcher.notify(new_routing, final_payload[i]);\n                }\n            } else if (final_payload[search_part] != undefined) {\n                final_payload = final_payload[search_part];\n                last_successful_search_part = search_part;\n                routing_path.push(search_part);\n            } else {\n                return false;\n            }\n        } else if (search_part != '*' && search_part != event_part) {\n            return false;\n        } else {\n            last_successful_search_part = event_part;\n            routing_path.push(event_part);\n        }\n    }\n\n    if (last_successful_search_part != null) {\n        var d = {};\n        d[last_successful_search_part] = final_payload;\n        final_payload = d;\n    }\n\n    return target_fn(final_payload, routing_path.join('.'));\n};\n\n\n// The dispatcher is very similar to the one described in the flux\n// documentation: https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html\n// This dispatcher is intended to be a singleton (but we don't enforce that)\nclass Dispatcher {\n    // A O(n) lookup of listeners, kept in order.\n    listeners: Array<any>;\n\n    // Events that are pending dispatch.\n    event_queue: Array<any>;\n\n    // This helps us keep track of what we are doing and prevents\n    // us from infinite looping (along with the queue).\n    is_dispatching: boolean;\n\n    // is capturing local storage events. We don't need to track this\n    // but it'll make it so more than one call to the method doesn't\n    // wrap the event handler unnessicarily.\n    is_capturing_local_storage_events: boolean;\n\n    // Name of the function on target objects that will be called\n    // whenever we receive a event that object is listening for.\n    function_name: string;\n\n    constructor() {\n        this.listeners = [];\n        this.event_queue = [];\n        this.is_dispatching = false;\n        this.is_capturing_local_storage_events = false;\n        this.function_name = 'setState';\n        this.is_dispatching = false;\n    }\n\n    // Call the `function_name` on the target object. By default\n    // this calls setState (which is the norm for React).\n    listen(routing_key, target, options) {\n        this.listeners.push([routing_key,\n            function () {\n                target.setState(arguments[0]);\n            },\n            options\n        ]);\n    }\n\n    // Listen with a custom function callback.\n    listen_fn(routing_key, target, options) {\n        this.listeners.push([routing_key, target, options]);\n    }\n\n    // Notify listeners that you have data for a key.\n    notify(event_routing_key, args) {\n        if (event_routing_key.indexOf('*') > -1) {\n            throw \"You can't notify with a *; use flush or broadcast.\";\n        }\n        this.event_queue.push([event_routing_key, args]);\n        if (!this.is_dispatching) {\n            this.flush_queue();\n        }\n    }\n\n    // Broadcast an event to all handlers, regardless of their listening key.\n    // This can be used to reset all of your handlers, or to notify them of some\n    // other global change.\n    broadcast(event) {\n        for (let obj of this.listeners) {\n            let fn = obj[1];\n            fn(event, '_');\n        }\n    }\n\n    // Flush will notify any listener that matches a \"startswith\" comparison\n    // Usage in documentation will give more insight into why you might need this.\n    flush(event_routing_key, args) {\n        for (let obj of this.listeners) {\n            let fn = obj[1];\n            let key = obj[0];\n            if (key.substring(0, event_routing_key.length) == event_routing_key) {\n                fn(args, '-');\n            }\n        }\n    }\n\n    flush_queue() {\n        this.is_dispatching = true;\n        // lets preserve the current_event queue.\n        let inner_queue = this.event_queue;\n\n        // and replace it with an empty queue, that way\n        // if events are created during the broadcast of\n        // the following events, we cant get into a\n        // infinite loop.\n        this.event_queue = [];\n\n        while (inner_queue.length) {\n            let item = inner_queue.slice(0, 1)[0];\n            inner_queue = inner_queue.slice(1);\n            this.dispatch_event(item[0], item[1]);\n        }\n\n        if (this.event_queue.length > 0) {\n            // somewhere in the process of dispatching\n            // these events more events came in.\n            // lets give the UI thread a chance to render\n            // and we'll start dispatching again.\n            let _this = this;\n            setTimeout(function () {\n                _this.flush_queue();\n            }, 5);\n        } else {\n            // No other events were created, so we can\n            // gracefully stop. Future calls to notify\n            // will call flush_queue().\n            this.is_dispatching = false;\n        }\n    }\n\n    // The actual work of dispatching a single event.\n    dispatch_event(event_routing_key, args) {\n        let remaining_listeners: Array<any> = [];\n\n        for (let row of this.listeners) {\n            let object_routing: string = row[0];\n            let object_target_fn: any = row[1];\n            let object_options: any = row[2];\n\n            try {\n                // Attempt to dispatch, with some extra rules to dig into objects.\n                dispatch_object_to_target(this,\n                    event_routing_key,\n                    object_routing,\n                    args,\n                    object_target_fn,\n                    object_options);\n\n                // If we make it here, we didn't throw an exception (or we didn't call fn)\n                remaining_listeners.push(row);\n            } catch (e) {\n                console.log('Dropping handler for `' + row[0] + '` on `' +\n                    typeof row[1].constructor + '` because of exception: ' + e);\n            }\n        }\n\n        this.listeners = remaining_listeners;\n    }\n\n    // Warning, this is here to show you how this might work, but it hides\n    // the fact that setItem will clobber complex objects ([], {}) into a\n    // string while adding them to the database.\n    capture_local_storage_changes() {\n        let _this = this;\n        if (this.is_capturing_local_storage_events) {\n            let originalSetItem = localStorage.setItem;\n            localStorage.setItem = function () {\n                originalSetItem.apply(this, arguments);\n                _this.notify(arguments[0], arguments[1]);\n            }\n            this.is_capturing_local_storage_events = true;\n        } else {\n            console.log(\"successive calls to capture_local_storage_changes are ignored.\");\n        }\n    }\n}\n\nlet global_dispatcher = new Dispatcher();\n\nexport { Dispatcher, global_dispatcher };\n\n\n\n// WEBPACK FOOTER //\n// ./src/dispatch.ts","import * as React from \"react\";\nimport { build_fn } from \"./text_to_filter_fun\";\nimport { global_dispatcher, debounce, mapMerge } from \"myproj-lib\";\n\nclass TableState {\n    query_value: string;\n    filterFn: (a: any, b: number, c: any[]) => boolean;\n    items: Array<any>;\n}\n\nclass TableProps {\n    initDocs: Array<any>\n}\n\nclass SearchableDataTable extends React.Component<TableProps, TableState> {\n    constructor(props) {\n        super(props);\n        this.state = {\n            query_value: '',\n            items: this.props.initDocs,\n            filterFn: () => true\n        };\n\n        this.handleChange = this.handleChange.bind(this);\n        this.handleSubmit = this.handleSubmit.bind(this);\n\n        this.handleChange = debounce(this.handleChange, 100);\n    }\n\n    handleChange(event) {\n        let next_state = {\n            query_value: event.target.value,\n            filterFn: build_fn(event.target.value)\n        };\n        this.setState(mapMerge(this.state, next_state));\n    }\n\n    handleSubmit(event) {\n        event.preventDefault();\n    }\n\n    getVisibleItems(): Array<any> {\n        return this.state.items.filter(this.state.filterFn).slice(0, 100);\n    }\n\n    renderRow(item) {\n        return <tr><td>Hello {item.num} {item.fuzzy}</td></tr>;\n    }\n\n    render() {\n        let visibleItems = this.getVisibleItems().map(this.renderRow);\n        return (\n            <div>\n                <form onSubmit={this.handleSubmit}>\n                    <label>Search</label>\n                    <input type=\"text\" value={this.state.query_value} onChange={this.handleChange} />\n                    <input type=\"submit\" value=\"Submit\" />\n                    <div>{visibleItems.length} of {this.state.items.length} items.</div>\n                </form>\n                <table>\n                    {visibleItems}\n                </table>\n            </div>\n        );\n    }\n}\n\nexport {\n    SearchableDataTable\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/simplesearch/src/table.tsx","/* \n   text_to_filter takes a simple (gmail like) search string and returns\n   a javascript function that accepts one argument, a javascript object,\n   and returns a true or false depending on if that object matches the\n   search string.\n\n   The primary goals are expressiveness and speed, with a secondary goals\n   on readability. This second goal is easy to overcome with macros which\n   allow search criteria rewriting per use (examples below).\n\n   Generated Function -> The function returned by calling build_fn with \n                         some search criteria.\n\n   Item -> Generally refers to the javascript object passed to the\n           generated function.\n\n   Search Type determines if a positive match will include or exclude the\n   item in the search result. Prepending a '\\' or '-' before a condition\n   sets that criteria to exclude, '+' or '/' for include (if neither are\n   present include is assumed).\n */\n\nenum SearchType {\n    Include,\n    Exclude\n};\n\n/* \n   Cond is the basic building block of all our comparisons, more detail\n   inline.\n\n   Where: \n     item  => passed in item.\n     key   => queried key.\n     value => value of argument\n*/\n\nenum Cond {\n    Exists,             // item[key] != undefined\n    Equal,              // item[key] == value OR item[key](value)\n    NotEqual,           // item[key] != value OR item[key](value)\n    LessThan,           // item[key] < value OR item[key](value)\n    GreaterThan,        // item[key] > value OR item[key](value)\n    ArgValueInItemSeq,  // value in item[key]\n    ItemValueInArgSeq,  // item[key] in value\n    Fuzzy               // See implementation.\n};\n\n/* \n   Composition types are part of every query,\n   determines how the set of conditions will be evaluated.\n*/\n\nenum ComposeType {\n    OR,          // Composeable OR\n    AND,         // Composeable AND\n    NAND,        // Composeable NAND\n    XOR          // Composeable XOR\n};\n\n// Start characters can only be one charater long, may add more here in\n// the future if needed.\nlet cond_lookup = {\n    '=': Cond.Equal,\n    '!': Cond.NotEqual,\n    '>': Cond.GreaterThan,\n    '<': Cond.LessThan,\n    '~': Cond.Fuzzy,\n    '?': Cond.Exists,\n    '$': Cond.ArgValueInItemSeq\n};\n\nlet cond_english_lookup = {};\nfor (let key in cond_lookup) {\n    cond_english_lookup[cond_lookup[key]] = key;\n}\n\n// Our cond function lookup.\nlet fn_lookup: any = {};\n\nfn_lookup[Cond.Equal] = function (value, arg) {\n    return value == arg;\n};\n\nfn_lookup[Cond.NotEqual] = function (value, arg) {\n    return value != arg;\n};\n\nfn_lookup[Cond.LessThan] = function (value, arg) {\n    return value < arg;\n};\n\nfn_lookup[Cond.GreaterThan] = function (value, arg) {\n    return value > arg;\n};\n\nfn_lookup[Cond.Exists] = function (value, arg) {\n    return value !== undefined;\n};\n\nfn_lookup[Cond.ArgValueInItemSeq] = function (value, arg) {\n    return value.indexOf(arg) != -1;\n};\n\nfn_lookup[Cond.ItemValueInArgSeq] = function (value, arg) {\n    return arg.indexOf(value) == -1;\n};\n\nfn_lookup[Cond.Fuzzy] = function (value, arg) {\n    let target_type = typeof (value);\n    if (arg.length == 0) { return false; }\n\n    // Coerce the type if both sides don't match.\n    if (target_type == undefined) {\n        return false;\n    } else if (target_type == \"string\") {\n        return value.search(arg) != -1;\n    } else if (target_type == \"number\") {\n        return (\"\" + value).search(arg) != -1;\n    }\n    return false;\n};\n\n// Tokenize a search in a way that we feel good about.\nlet safe_split = function safe_split(s: string, split_char: string, strip_block_chars?: boolean): Array<any> {\n    if (strip_block_chars == undefined) {\n        strip_block_chars = false;\n    }\n\n    let block_chars = {\n        '\"': '\"',\n        \"'\": \"'\",\n        '(': ')',\n        '[': ']',\n        '`': '`'\n    };\n\n    var partitions = [];\n    var current_word = [];\n    var in_block = false;\n    var block_start_char = null;\n\n    for (var i = 0; i < s.length; i++) {\n        var chr = s[i];\n        if (in_block) {\n            if (chr == block_chars[block_start_char]) {\n                if (!strip_block_chars) {\n                    current_word.push(chr);\n                }\n                in_block = false;\n                block_start_char = null;\n            } else {\n                current_word.push(chr);\n            }\n        } else {\n            if (split_char.indexOf(chr) != -1) {\n                partitions.push(current_word.join(''));\n                current_word = [];\n            } else {\n                if (block_chars[chr] != undefined) {\n                    // we should start a block\n                    in_block = true;\n                    block_start_char = chr;\n                    if (!strip_block_chars) {\n                        current_word.push(chr);\n                    }\n                } else {\n                    current_word.push(chr);\n                }\n            }\n        }\n    }\n\n    if (current_word.length) {\n        partitions.push(current_word.join(''));\n    }\n    return partitions;\n};\n\n// Create a set of search tokens given a search query.\nlet string_to_search_tokens = function (s: string): Array<any> {\n    let fuzzy_token = [];\n    let final_tokens = [];\n    let init_tokens = safe_split(s, ' ');\n\n    for (let tok of init_tokens) {\n        let index = tok.search(':')\n        if (index == -1) {\n            fuzzy_token.push([Cond.Fuzzy, tok]);\n        } else {\n            let key = tok.slice(0, index);\n            let arg_list = safe_split(tok.slice(index + 1), ',', true);\n            let new_token = gen_token_from_key_args(key, arg_list);\n            if (new_token) {\n                final_tokens.push(new_token);\n            }\n        }\n    }\n\n    final_tokens.push([SearchType.Include, 'fuzzy', ComposeType.OR, fuzzy_token]);\n\n    return final_tokens;\n};\n\n// Convert a token to something readable by a human.\nlet token_to_english = function (token: Array<any>): string {\n    let [addrem, key, compose_type, args] = token;\n    let s = [];\n\n    // Search Type\n    s.push(SearchType[addrem]);\n    s.push(`results where ${key} matches`);\n\n    s.push(args.map(function (arg) {\n        return ' ' + Cond[arg[0]] + ' |' + arg[1] + '| ';\n    }).join(ComposeType[compose_type]));\n\n    return s.join(' ');\n};\n\n// Convert a token back to a safe query value.\nlet token_to_query = function (token: Array<any>): string {\n    let [addrem, key, compose_type, args] = token;\n    let s = [];\n\n    if (addrem == SearchType.Include) {\n        //pass\n    } else if (addrem == SearchType.Exclude) {\n        s.push('-');\n    }\n\n    s.push(key);\n    s.push(':');\n\n    if (compose_type == ComposeType.AND) {\n        s.push('&,');\n    }\n\n    s.push(args.map(function (arg) {\n        return \"`\" + cond_english_lookup[arg[0]] + arg[1] + \"`\";\n    }).join(','));\n\n    return s.join('');\n};\n\n// Generate a token for a given key and it's arguments.\nlet gen_token_from_key_args = function (key: string, arg_list: Array<string>): Array<any> {\n    // Determine if this search is inclusive or exclusive.\n    let addrem = SearchType.Include;\n    let cond = Cond.Equal;\n    let compose_type = ComposeType.OR;\n\n    if (key[0] == '-') {\n        addrem = SearchType.Exclude;\n        key = key.slice(1);\n    } else if (key[0] == '+') {\n        addrem = SearchType.Include;\n        key = key.slice(1);\n    }\n\n    if (arg_list.length == 0) {\n        return null;\n    }\n\n    if (arg_list[0] == '&') {\n        compose_type = ComposeType.AND;\n        arg_list = arg_list.slice(1);\n    }\n\n    let new_arg_list = [];\n\n    for (let arg of arg_list) {\n        let cond = Cond.Equal;\n        let narg: any = arg;\n\n        if (cond_lookup.hasOwnProperty(arg[0])) {\n            cond = cond_lookup[arg[0]];\n            narg = arg.slice(1);\n        }\n\n        if (!isNaN(+narg)) {\n            narg = +narg;\n        }\n        if (narg == 't' || narg == 'true') {\n            narg = true;\n        } else if (narg == 'f' || narg == 'false') {\n            narg = false;\n        }\n\n        new_arg_list.push([cond, narg]);\n    }\n\n    let new_token = [\n        addrem,\n        key,\n        compose_type,\n        new_arg_list\n    ];\n\n    return new_token;\n};\n\n// If a key is referencing nested data, retrieve it.\nlet dig_key_value = function (key, value): any {\n    let key_parts = key.split('.');\n\n    if (key_parts.length == 1) {\n        return value[key];\n    } else {\n        for (let part of key_parts) {\n            if (value[part] == undefined) {\n                return undefined;\n            }\n            value = value[part];\n        }\n    }\n    return value;\n}\n\n// Compose a list of tokens and then use the build_filter_fn_from_tokens\n// to create a function for the user to filter with.\nlet build_fn = function (q: string, options?: {}): any {\n    if (options == undefined) {\n        options = {};\n    }\n\n    let fuzzy_key = options['fuzzy_key'] || 'fuzzy';\n    let macro_map = options['macros'] || {};\n\n    let final_tokens = string_to_search_tokens(q);\n    let condition_fns = [];\n\n    for (let outer_token of final_tokens) {\n        var lambda = function (item: any): boolean {\n            let ret = true;\n            let [addrem, key, compose_type, args] = outer_token;\n            let value = dig_key_value(key, item);\n\n            for (let arg of args) {\n                let fn_cond_enum = arg[0];\n\n                try {\n                    if (typeof value == \"function\") {\n                        if (fn_cond_enum == Cond.Exists) {\n                            ret = true;\n                        } else {\n                            ret = value.apply(item, [arg[1]]);\n                        }\n                    } else if (typeof value == \"undefined\") {\n                        ret = false;\n                    } else {\n                        ret = fn_lookup[fn_cond_enum](value, arg[1]);\n                    }\n                } catch (e) {\n                    console.log(\"Exception in cond: \", fn_lookup[fn_cond_enum]);;\n                    ret = true;\n                }\n\n                if (addrem == SearchType.Include) {\n                    //ret;\n                } else if (addrem == SearchType.Exclude) {\n                    ret = !ret;\n                }\n\n                if (compose_type == ComposeType.OR && ret == true) {\n                    return true;\n                } else if (compose_type == ComposeType.AND && ret == false) {\n                    return false;\n                }\n            }\n\n            return ret;\n        };\n        condition_fns.push(lambda);\n    }\n\n    //console.log(JSON.stringify(final_tokens));\n    return function (item: any, _index: number, _accum: any[]): any {\n        for (let fn of condition_fns) {\n            if (fn(item) == false) {\n                return false;\n            }\n        }\n        return true;\n    };\n};\n\nexport {\n    build_fn,\n    string_to_search_tokens,\n    token_to_english\n};\n\n\n\n// WEBPACK FOOTER //\n// ./app/simplesearch/src/text_to_filter_fun.ts"],"sourceRoot":""}