{"version":3,"sources":["webpack:///home.bundle.js","webpack:///./app/home/src/main.tsx","webpack:///./src/lib.tsx","webpack:///./src/dispatch.ts"],"names":["webpackJsonp","module","exports","__webpack_require__","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","React","ReactDOM","myproj_lib_1","HelloWorld","_super","apply","arguments","render","createElement","Component","document","getElementById","test_lib_working","ensureValidKeys","state","ensureKeys","LOADED_KEY","return_state","undefined","_i","ensureKeys_1","length","key","is_loaded","console","log","dispatch_1","global_dispatcher","dispatch_object_to_target","_dispatcher","event","routing_search","payload","target_fn","options","sp_event","split","sp_search","final_payload","routing_path","last_successful_search_part","index","event_part","search_part","new_routing_root","join","i","new_routing","notify","push","Dispatcher","listeners","event_queue","is_dispatching","is_capturing_local_storage_events","function_name","listen","routing_key","target","setState","listen_fn","event_routing_key","args","indexOf","flush_queue","broadcast","_a","obj","fn","flush","substring","inner_queue","item","slice","dispatch_event","_this_1","setTimeout","remaining_listeners","row","object_routing","object_target_fn","object_options","e","capture_local_storage_changes","_this","originalSetItem_1","localStorage","setItem"],"mappings":"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","file":"home.bundle.js","sourcesContent":["webpackJsonp([0],[\n/* 0 */\n/*!*******************************!*\\\n  !*** ./app/home/src/main.tsx ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar React = __webpack_require__(/*! react */ 1);\n\tvar ReactDOM = __webpack_require__(/*! react-dom */ 1);\n\tvar myproj_lib_1 = __webpack_require__(/*! myproj-lib */ 5);\n\tvar HelloWorld = (function (_super) {\n\t    __extends(HelloWorld, _super);\n\t    function HelloWorld() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    HelloWorld.prototype.render = function () {\n\t        return React.createElement(\"div\", null, \" Hello World; from home! \");\n\t    };\n\t    return HelloWorld;\n\t}(React.Component));\n\tReactDOM.render(React.createElement(HelloWorld, null), document.getElementById('content'));\n\tmyproj_lib_1.test_lib_working();\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/*!*********************!*\\\n  !*** ./src/lib.tsx ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar dispatch_1 = __webpack_require__(/*! ./dispatch */ 6);\n\texports.global_dispatcher = dispatch_1.global_dispatcher;\n\tfunction ensureValidKeys(state, ensureKeys) {\n\t    var LOADED_KEY = \"is_loaded\";\n\t    var return_state = {};\n\t    if (state[LOADED_KEY] !== undefined) {\n\t        throw (\"Cant use `is_loaded` as key in state for ensureValidKeys\");\n\t    }\n\t    for (var _i = 0, ensureKeys_1 = ensureKeys; _i < ensureKeys_1.length; _i++) {\n\t        var key = ensureKeys_1[_i];\n\t        if (!state[key]) {\n\t            return { \"is_loaded\": false };\n\t        }\n\t        return_state[key] = state[key];\n\t    }\n\t    return_state[\"is_loaded\"] = true;\n\t    return return_state;\n\t}\n\texports.ensureValidKeys = ensureValidKeys;\n\tfunction test_lib_working() {\n\t    console.log(\"Lib is working!\");\n\t}\n\texports.test_lib_working = test_lib_working;\n\n\n/***/ },\n/* 6 */\n/*!*************************!*\\\n  !*** ./src/dispatch.ts ***!\n  \\*************************/\n/***/ function(module, exports) {\n\n\t/*\n\t   Dispatching events isn't as easy as you want it to be.\n\t\n\t   While the Dispatcher object (below) is relatively simple, the ruleset\n\t   that determines what to dispatch is a little more complex.\n\t\n\t   In a simple case, a object registers for a simple event:\n\t\n\t     global_dispatch.listen('page.tick', mytarget);\n\t\n\t   When notify() is called with 'page.tick', the `mytarget` object has its\n\t   `setState` method called with whatever arg is passed to the notify()\n\t   method. When the number of 'parts' is equal, this comparison is simple\n\t   the parts must match (or the search must be a '*').\n\t\n\t   Thus, 'page.*' would match 'page.tick', but not 'otherthing.tick'.\n\t\n\t   While this would be good enough for most cases, we want to avoid\n\t   the following.\n\t\n\t     // This is what we want to avoid.\n\t     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n\t        console.log(\"The ID is: \" + payload.info.id);\n\t     });\n\t\n\t     // dispatch our complex user object.\n\t     global_dispatch.notify('user.123', {'info':{'id':1}});\n\t\n\t     // dispatch a different piece of user data.\n\t     // This would result in an error.\n\t     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\t\n\t   Instead, since we know the search path, we can dig into the payload\n\t   object, and return only what the listener asked for.\n\t\n\t   Thus,\n\t\n\t     // This is what we actually do.\n\t     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n\t        console.log(\"The ID is \" + payload.id);\n\t     });\n\t\n\t     // dispatch our complex user object, the above will be called.\n\t     global_dispatch.notify('user.123', {'info':{'id':1}});\n\t\n\t     // dispatch a different piece of user data.\n\t     // This will not invoke the handler above, because the\n\t     // route did not match. See `dispatch_object_to_target`\n\t     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\t\n\t   This avoids nasty bugs, and makes sure that your handlers\n\t   only ever get the data they requested. Handlers can use * at the\n\t   end of their match in order to get all the keys.\n\t\n\t   Keep in mind this only works for events that are dictionaries\n\t   or objects.\n\t*/\n\t\"use strict\";\n\tfunction dispatch_object_to_target(_dispatcher, event, routing_search, payload, target_fn, options) {\n\t    var sp_event = event.split('.');\n\t    var sp_search = routing_search.split('.');\n\t    var final_payload = payload;\n\t    var routing_path = [];\n\t    var last_successful_search_part = null;\n\t    for (var index = 0; index < sp_search.length; index++) {\n\t        var event_part = sp_event[index];\n\t        var search_part = sp_search[index];\n\t        if (event_part == undefined) {\n\t            if (search_part == '*') {\n\t                var new_routing_root = routing_path.join('.');\n\t                for (var i in final_payload) {\n\t                    var new_routing = new_routing_root + '.' + i;\n\t                    console.log(\"new event: \" + new_routing);\n\t                    _dispatcher.notify(new_routing, final_payload[i]);\n\t                }\n\t            }\n\t            else if (final_payload[search_part] != undefined) {\n\t                final_payload = final_payload[search_part];\n\t                last_successful_search_part = search_part;\n\t                routing_path.push(search_part);\n\t            }\n\t            else {\n\t                return false;\n\t            }\n\t        }\n\t        else if (search_part != '*' && search_part != event_part) {\n\t            return false;\n\t        }\n\t        else {\n\t            last_successful_search_part = event_part;\n\t            routing_path.push(event_part);\n\t        }\n\t    }\n\t    if (last_successful_search_part != null) {\n\t        var d = {};\n\t        d[last_successful_search_part] = final_payload;\n\t        final_payload = d;\n\t    }\n\t    return target_fn(final_payload, routing_path.join('.'));\n\t}\n\t;\n\t// The dispatcher is very similar to the one described in the flux\n\t// documentation: https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html\n\t// This dispatcher is intended to be a singleton (but we don't enforce that)\n\tvar Dispatcher = (function () {\n\t    function Dispatcher() {\n\t        this.listeners = [];\n\t        this.event_queue = [];\n\t        this.is_dispatching = false;\n\t        this.is_capturing_local_storage_events = false;\n\t        this.function_name = 'setState';\n\t        this.is_dispatching = false;\n\t    }\n\t    // Call the `function_name` on the target object. By default\n\t    // this calls setState (which is the norm for React).\n\t    Dispatcher.prototype.listen = function (routing_key, target, options) {\n\t        this.listeners.push([routing_key,\n\t            function () {\n\t                target.setState(arguments[0]);\n\t            },\n\t            options\n\t        ]);\n\t    };\n\t    // Listen with a custom function callback.\n\t    Dispatcher.prototype.listen_fn = function (routing_key, target, options) {\n\t        this.listeners.push([routing_key, target, options]);\n\t    };\n\t    // Notify listeners that you have data for a key.\n\t    Dispatcher.prototype.notify = function (event_routing_key, args) {\n\t        if (event_routing_key.indexOf('*') > -1) {\n\t            throw \"You can't notify with a *; use flush or broadcast.\";\n\t        }\n\t        this.event_queue.push([event_routing_key, args]);\n\t        if (!this.is_dispatching) {\n\t            this.flush_queue();\n\t        }\n\t    };\n\t    // Broadcast an event to all handlers, regardless of their listening key.\n\t    // This can be used to reset all of your handlers, or to notify them of some\n\t    // other global change.\n\t    Dispatcher.prototype.broadcast = function (event) {\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var obj = _a[_i];\n\t            var fn = obj[1];\n\t            fn(event, '_');\n\t        }\n\t    };\n\t    // Flush will notify any listener that matches a \"startswith\" comparison\n\t    // Usage in documentation will give more insight into why you might need this.\n\t    Dispatcher.prototype.flush = function (event_routing_key, args) {\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var obj = _a[_i];\n\t            var fn = obj[1];\n\t            var key = obj[0];\n\t            if (key.substring(0, event_routing_key.length) == event_routing_key) {\n\t                fn(args, '-');\n\t            }\n\t        }\n\t    };\n\t    Dispatcher.prototype.flush_queue = function () {\n\t        this.is_dispatching = true;\n\t        // lets preserve the current_event queue.\n\t        var inner_queue = this.event_queue;\n\t        // and replace it with an empty queue, that way\n\t        // if events are created during the broadcast of\n\t        // the following events, we cant get into a\n\t        // infinite loop.\n\t        this.event_queue = [];\n\t        while (inner_queue.length) {\n\t            var item = inner_queue.slice(0, 1)[0];\n\t            inner_queue = inner_queue.slice(1);\n\t            this.dispatch_event(item[0], item[1]);\n\t        }\n\t        if (this.event_queue.length > 0) {\n\t            // somewhere in the process of dispatching\n\t            // these events more events came in.\n\t            // lets give the UI thread a chance to render\n\t            // and we'll start dispatching again.\n\t            var _this_1 = this;\n\t            setTimeout(function () {\n\t                _this_1.flush_queue();\n\t            }, 5);\n\t        }\n\t        else {\n\t            // No other events were created, so we can\n\t            // gracefully stop. Future calls to notify\n\t            // will call flush_queue().\n\t            this.is_dispatching = false;\n\t        }\n\t    };\n\t    // The actual work of dispatching a single event.\n\t    Dispatcher.prototype.dispatch_event = function (event_routing_key, args) {\n\t        var remaining_listeners = [];\n\t        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {\n\t            var row = _a[_i];\n\t            var object_routing = row[0];\n\t            var object_target_fn = row[1];\n\t            var object_options = row[2];\n\t            try {\n\t                // Attempt to dispatch, with some extra rules to dig into objects.\n\t                dispatch_object_to_target(this, event_routing_key, object_routing, args, object_target_fn, object_options);\n\t                // If we make it here, we didn't throw an exception (or we didn't call fn)\n\t                remaining_listeners.push(row);\n\t            }\n\t            catch (e) {\n\t                console.log('Dropping handler for `' + row[0] + '` on `' +\n\t                    typeof row[1].constructor + '` because of exception: ' + e);\n\t            }\n\t        }\n\t        this.listeners = remaining_listeners;\n\t    };\n\t    // Warning, this is here to show you how this might work, but it hides\n\t    // the fact that setItem will clobber complex objects ([], {}) into a\n\t    // string while adding them to the database.\n\t    Dispatcher.prototype.capture_local_storage_changes = function () {\n\t        var _this = this;\n\t        if (this.is_capturing_local_storage_events) {\n\t            var originalSetItem_1 = localStorage.setItem;\n\t            localStorage.setItem = function () {\n\t                originalSetItem_1.apply(this, arguments);\n\t                _this.notify(arguments[0], arguments[1]);\n\t            };\n\t            this.is_capturing_local_storage_events = true;\n\t        }\n\t        else {\n\t            console.log(\"successive calls to capture_local_storage_changes are ignored.\");\n\t        }\n\t    };\n\t    return Dispatcher;\n\t}());\n\texports.Dispatcher = Dispatcher;\n\tvar global_dispatcher = new Dispatcher();\n\texports.global_dispatcher = global_dispatcher;\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// home.bundle.js","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport { test_lib_working } from \"myproj-lib\";\n\nclass HelloWorld extends React.Component<{}, {}> {\n    render() {\n        return <div> Hello World; from home! </div>;\n    }\n}\n\nReactDOM.render(<HelloWorld />,\n    document.getElementById('content'));\n\ntest_lib_working();\n\n\n\n// WEBPACK FOOTER //\n// ./app/home/src/main.tsx","import { global_dispatcher } from \"./dispatch\";\n\nfunction ensureValidKeys(state: any, ensureKeys: Array<string>): any {\n    var LOADED_KEY = \"is_loaded\";\n    var return_state: any = {};\n\n    if (state[LOADED_KEY] !== undefined) {\n        throw (\"Cant use `is_loaded` as key in state for ensureValidKeys\");\n    }\n\n    for (var key of ensureKeys) {\n        if (!state[key]) {\n            return { \"is_loaded\": false };\n        }\n        return_state[key] = state[key];\n    }\n\n    return_state[\"is_loaded\"] = true;\n\n    return return_state;\n}\n\nfunction test_lib_working() {\n    console.log(\"Lib is working!\");\n}\n\nexport {\n    test_lib_working,\n    ensureValidKeys,\n    global_dispatcher\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib.tsx","/* \n   Dispatching events isn't as easy as you want it to be.\n\n   While the Dispatcher object (below) is relatively simple, the ruleset\n   that determines what to dispatch is a little more complex.\n\n   In a simple case, a object registers for a simple event:\n\n     global_dispatch.listen('page.tick', mytarget);\n\n   When notify() is called with 'page.tick', the `mytarget` object has its\n   `setState` method called with whatever arg is passed to the notify()\n   method. When the number of 'parts' is equal, this comparison is simple\n   the parts must match (or the search must be a '*').\n\n   Thus, 'page.*' would match 'page.tick', but not 'otherthing.tick'.\n\n   While this would be good enough for most cases, we want to avoid\n   the following.\n\n     // This is what we want to avoid.\n     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n        console.log(\"The ID is: \" + payload.info.id);\n     });\n\n     // dispatch our complex user object.\n     global_dispatch.notify('user.123', {'info':{'id':1}});\n\n     // dispatch a different piece of user data.\n     // This would result in an error.\n     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\n   Instead, since we know the search path, we can dig into the payload\n   object, and return only what the listener asked for.\n\n   Thus, \n\n     // This is what we actually do.\n     global_dispatch.listen_fn('user.*.info.id', (payload) => {\n        console.log(\"The ID is \" + payload.id);\n     });\n\n     // dispatch our complex user object, the above will be called.\n     global_dispatch.notify('user.123', {'info':{'id':1}});\n\n     // dispatch a different piece of user data.\n     // This will not invoke the handler above, because the\n     // route did not match. See `dispatch_object_to_target`\n     global_dispatch.notify('user.123', {'other':{'stuff':1}});\n\n   This avoids nasty bugs, and makes sure that your handlers\n   only ever get the data they requested. Handlers can use * at the\n   end of their match in order to get all the keys.\n\n   Keep in mind this only works for events that are dictionaries\n   or objects.\n*/\n\nfunction dispatch_object_to_target(_dispatcher: Dispatcher, event: string,\n    routing_search: string, payload: any,\n    target_fn: any, options: any): any {\n    let sp_event: Array<string> = event.split('.');\n    let sp_search: Array<string> = routing_search.split('.');\n    let final_payload = payload;\n    let routing_path = [];\n    let last_successful_search_part = null;\n\n    for (let index = 0; index < sp_search.length; index++) {\n        let event_part = sp_event[index];\n        let search_part = sp_search[index];\n\n        if (event_part == undefined) {\n            if (search_part == '*') {\n                let new_routing_root = routing_path.join('.');\n                for (let i in final_payload) {\n                    let new_routing = new_routing_root + '.' + i;\n                    console.log(\"new event: \" + new_routing);\n                    _dispatcher.notify(new_routing, final_payload[i]);\n                }\n            } else if (final_payload[search_part] != undefined) {\n                final_payload = final_payload[search_part];\n                last_successful_search_part = search_part;\n                routing_path.push(search_part);\n            } else {\n                return false;\n            }\n        } else if (search_part != '*' && search_part != event_part) {\n            return false;\n        } else {\n            last_successful_search_part = event_part;\n            routing_path.push(event_part);\n        }\n    }\n\n    if (last_successful_search_part != null) {\n        var d = {};\n        d[last_successful_search_part] = final_payload;\n        final_payload = d;\n    }\n\n    return target_fn(final_payload, routing_path.join('.'));\n};\n\n\n// The dispatcher is very similar to the one described in the flux\n// documentation: https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html\n// This dispatcher is intended to be a singleton (but we don't enforce that)\nclass Dispatcher {\n    // A O(n) lookup of listeners, kept in order.\n    listeners: Array<any>;\n\n    // Events that are pending dispatch.\n    event_queue: Array<any>;\n\n    // This helps us keep track of what we are doing and prevents\n    // us from infinite looping (along with the queue).\n    is_dispatching: boolean;\n\n    // is capturing local storage events. We don't need to track this\n    // but it'll make it so more than one call to the method doesn't\n    // wrap the event handler unnessicarily.\n    is_capturing_local_storage_events: boolean;\n\n    // Name of the function on target objects that will be called\n    // whenever we receive a event that object is listening for.\n    function_name: string;\n\n    constructor() {\n        this.listeners = [];\n        this.event_queue = [];\n        this.is_dispatching = false;\n        this.is_capturing_local_storage_events = false;\n        this.function_name = 'setState';\n        this.is_dispatching = false;\n    }\n\n    // Call the `function_name` on the target object. By default\n    // this calls setState (which is the norm for React).\n    listen(routing_key, target, options) {\n        this.listeners.push([routing_key,\n            function () {\n                target.setState(arguments[0]);\n            },\n            options\n        ]);\n    }\n\n    // Listen with a custom function callback.\n    listen_fn(routing_key, target, options) {\n        this.listeners.push([routing_key, target, options]);\n    }\n\n    // Notify listeners that you have data for a key.\n    notify(event_routing_key, args) {\n        if (event_routing_key.indexOf('*') > -1) {\n            throw \"You can't notify with a *; use flush or broadcast.\";\n        }\n        this.event_queue.push([event_routing_key, args]);\n        if (!this.is_dispatching) {\n            this.flush_queue();\n        }\n    }\n\n    // Broadcast an event to all handlers, regardless of their listening key.\n    // This can be used to reset all of your handlers, or to notify them of some\n    // other global change.\n    broadcast(event) {\n        for (let obj of this.listeners) {\n            let fn = obj[1];\n            fn(event, '_');\n        }\n    }\n\n    // Flush will notify any listener that matches a \"startswith\" comparison\n    // Usage in documentation will give more insight into why you might need this.\n    flush(event_routing_key, args) {\n        for (let obj of this.listeners) {\n            let fn = obj[1];\n            let key = obj[0];\n            if (key.substring(0, event_routing_key.length) == event_routing_key) {\n                fn(args, '-');\n            }\n        }\n    }\n\n    flush_queue() {\n        this.is_dispatching = true;\n        // lets preserve the current_event queue.\n        let inner_queue = this.event_queue;\n\n        // and replace it with an empty queue, that way\n        // if events are created during the broadcast of\n        // the following events, we cant get into a\n        // infinite loop.\n        this.event_queue = [];\n\n        while (inner_queue.length) {\n            let item = inner_queue.slice(0, 1)[0];\n            inner_queue = inner_queue.slice(1);\n            this.dispatch_event(item[0], item[1]);\n        }\n\n        if (this.event_queue.length > 0) {\n            // somewhere in the process of dispatching\n            // these events more events came in.\n            // lets give the UI thread a chance to render\n            // and we'll start dispatching again.\n            let _this = this;\n            setTimeout(function () {\n                _this.flush_queue();\n            }, 5);\n        } else {\n            // No other events were created, so we can\n            // gracefully stop. Future calls to notify\n            // will call flush_queue().\n            this.is_dispatching = false;\n        }\n    }\n\n    // The actual work of dispatching a single event.\n    dispatch_event(event_routing_key, args) {\n        let remaining_listeners: Array<any> = [];\n\n        for (let row of this.listeners) {\n            let object_routing: string = row[0];\n            let object_target_fn: any = row[1];\n            let object_options: any = row[2];\n\n            try {\n                // Attempt to dispatch, with some extra rules to dig into objects.\n                dispatch_object_to_target(this,\n                    event_routing_key,\n                    object_routing,\n                    args,\n                    object_target_fn,\n                    object_options);\n\n                // If we make it here, we didn't throw an exception (or we didn't call fn)\n                remaining_listeners.push(row);\n            } catch (e) {\n                console.log('Dropping handler for `' + row[0] + '` on `' +\n                    typeof row[1].constructor + '` because of exception: ' + e);\n            }\n        }\n\n        this.listeners = remaining_listeners;\n    }\n\n    // Warning, this is here to show you how this might work, but it hides\n    // the fact that setItem will clobber complex objects ([], {}) into a\n    // string while adding them to the database.\n    capture_local_storage_changes() {\n        let _this = this;\n        if (this.is_capturing_local_storage_events) {\n            let originalSetItem = localStorage.setItem;\n            localStorage.setItem = function () {\n                originalSetItem.apply(this, arguments);\n                _this.notify(arguments[0], arguments[1]);\n            }\n            this.is_capturing_local_storage_events = true;\n        } else {\n            console.log(\"successive calls to capture_local_storage_changes are ignored.\");\n        }\n    }\n}\n\nlet global_dispatcher = new Dispatcher();\n\nexport { Dispatcher, global_dispatcher };\n\n\n\n// WEBPACK FOOTER //\n// ./src/dispatch.ts"],"sourceRoot":""}